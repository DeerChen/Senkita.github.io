# 互斥锁、读写锁、条件变量与原子操作

## 并发和并行

1. 多线程程序在单核上运行为并发，同一时间点单任务运行
2. 多线程程序在多核上运行为并行，多任务在同一时间点运行

## 协程

1. 独立栈空间
2. 共享堆空间
3. 调度由用户控制
4. 轻量级线程

## 互斥锁

竞态条件`race condition`是指数据被多个线程共享，产生争用和冲突，往往会破坏共享数据的一致性。
多个并发运行的线程对共享资源的访问是完全串行的，由于要访问资源而必须进入的区域叫临界区(`critical section`)。
互斥量`mutual exclusion`可以用来保护一个临界区或一组相关临界区，用于保证同一时刻只有一个协程进入临界区。

```go
package main

import (
	"sync"
	"runtime"
)

var mtx sync.Mutex

func main() {
	// 不要重复上锁，否则会阻塞协程
	// 不要跨函数直接传递互斥锁，多副本之间的互斥锁完全独立，没有意义
	mtx.Lock()
	// 不要忘记解锁，必要时使用defer
	// 不要对未上锁或已解锁的互斥锁解锁
	mtx.Unlock()
}
```

死锁`deadlock`即所有用户级协程全部处于等待状态，程序必然崩溃。

## 读写锁

`sync.RWMutex`中，多个写无法同时进行，读与写无法同时进行，但多个读可以同时进行。

## 条件变量

条件变量(`conditional variable`)是用于协调想要访问共享资源的那些线程的。

```go
package main

import (
	"sync"
	"runtime"
)

var (
	mailbox uint8
	lock    sync.RWMutex
)

func main() {
	// 获取当前系统CPU数
	cpuNum := runtime.NumCPU()
	runtime.GOMAXPROCS(cpuNum)

	// 条件变量基于互斥锁，需要一个sync.Locker类型的参数
	sendCond := sync.NewCond(&lock)
	recvCond := sync.NewCond(lock.RLocker())

	sign := make(chan struct{}, 3)
	go func() {
		defer func() {
			sign <- struct{}{}
        }()
        // 由于可能共享资源状态有多个，遇到状态不是想要的就要使用for来持续访问
		for i := 1; i <= 5; i++ {
			lock.Lock()
			for mailbox == 1 {
                // Wait方法先把调用它的协程加入到当前条件变量的通知队列中，然后解锁条件变量所基于的互斥锁，让当前协程处于等待状态，等待通知到来唤醒重新锁定互斥锁
				sendCond.Wait()
			}
			mailbox = 1
            lock.Unlock()
            // Signal只会唤醒队首等待的协程，而Broadcast将会唤醒所有协程
			recvCond.Signal()
		}
	}()
	go func() {
		defer func() {
			sign <- struct{}{}
		}()
		for j := 1; j <= 5; j++ {
			lock.RLock()
			for mailbox == 0 {
				recvCond.Wait()
			}
			mailbox = 0
            lock.RUnlock()
            // Signal方法无需锁保护。
            // 条件变量的通知具有即时性，如果当下没有协程等待，通知将被丢弃。
			sendCond.Signal()
		}
	}()
	<-sign
	<-sign
}
```

## 原子操作

能真正保证原子性执行的只有原子操作，可以完全消除竞态条件，并能够绝对保证并发安全性。
原子操作不能被中断，所以要求足够简单而且快速。但如果原子操作迟迟不能完成，将会给计算机执行指令效率带来极大影响，所以操作系统层面只针对二进制位或整数的原子操作提供支持。
sync.atomic 包中的原子操作有`add`加法、`compare and swap`比较并交换、`load`加载、`store`存储和`swap`交换。
可操作的数据类型有`int32`、`int64`、`uint32`、`uint64`、`uintptr`和`unsafe.Pointer`。

## 自旋锁

`CAS`算法是一种无锁算法，即不使用锁的情况下实现多线程之间变量同步，也叫非阻塞同步(`Non-blocking Synchronization`)。

```go
package main

import (
	"runtime"
	"sync"
	"sync/atomic"
)

type spinLock uint32

func (sl *spinLock) Lock() {
	// 当且仅当需要读写的内存值等于进行比较的值时，以原子操作的方式用新值来替换原值，一般情况下是个自旋操作，即不断重试直至满足条件
	for !atomic.CompareAndSwapUint32((*uint32)(sl), 0, 1) {
		runtime.Gosched()
	}
}
func (sl *spinLock) Unlock() {
	atomic.StoreUint32((*uint32)(sl), 0)
}

func NewSpinLock() sync.Locker {
	var lock spinLock
	return &lock
}
```
