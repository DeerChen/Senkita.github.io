# 结构体与接口

## Go 支持面向对象么？

结构体将属性和方法封装在了一起，表现了面对对象编程(`object-oriented programming`)。

```go
package main

import "fmt"

// 结构体类型是数据结构
type Animal struct {
	kind string
}
type Person struct {
    // 嵌入组合
    Animal

    name string
}

// 函数可以匿名，方法必须拥有名字，而且必须做接收者(receiver)声明
// 接收者声明表示隶属类型，但不限定于结构体
func (a Animal) String() string {
	return a.kind
}

// 同名方法会重载，有屏蔽现象
func (p Person) String() string {
	return p.Animal.String()
}

func main() {
	p := Person{
		name:   "Lili",
		Animal: Animal{kind: "human"},
	}
	fmt.Println(p.String())
}
```

## Go 是用嵌入字段实现继承么？

`Go`支持`OOP`，但没有继承的概念，而是嵌入组合。
`OOP`中的继承是牺牲一定代码简洁性来换取可扩展性，而且这种可扩展性是侵入式实现。
类型组合采用的是非声明的方式，是非侵入式的，不会破坏类型的封装或加重类型之间的耦合。

## 值方法与指针方法

方法的接收者类型必须是某个自定义的数据类型，而不能是接口类型或者是接口的指针类型。
值方法的接收者式该方法所属的类型值副本，方法内对副本的修改不会影响到原值，除非这个类型是引用类型。
一个自定义数据类型的方法集合仅会包含它的所有值方法，而该类型的指针类型方法集合包含所有值方法和指针方法。

```go
package main

import (
	"fmt"
)

// 结构体包裹字段声明
type Dog struct {
	name string
}
type Cat struct {
	name string
}

// 接口包裹方法定义
// 接口类型不会有重名，否则无法通过编译
type Pet interface {
	Call()
	SetName(name string)
}

// 值方法
func (d Dog) SetName(name string) {
	d.name = name
}

func (d Dog) Call() {
	fmt.Println(d.name)
}

// 指针方法
func (c *Cat) SetName(name string) {
	c.name = name
}
func (c Cat) Call() {
	fmt.Println(c.name)
}

func main() {
	kitty := Cat{"kitty"}
	doge := Dog{"dog"}

	// Pet为静态值，Dog和*Cat为动态类型
	var p1 Pet = &kitty

	kitty.SetName("cat")
	p1.SetName("Kitty")
	p1.Call()
	kitty.Call()

	// 赋值传递的是副本，则不会变动原值
	var p2 Pet = doge

	// 值方法传递的也是副本，原值不会变动
	doge.SetName("doge")
	doge.Call()
	p2.SetName("doge")
	p2.Call()
}
```

接口类型无法被值化或实例化，如果没有任何数据类型作为其实现，则该接口的值不可能存在。
动态类型如果为`nil`，`Go`会用专有数据结构`iface`的实例包装这个副本，这样它就变成了一个有类型的`nil`。

## Duck Typing

1. 如果一个数据类型的方法集合完全包含了接口的方法集合，那它就是这个接口的实现类型
2. 如果两个方法的签名完全一致，且名称一模一样，则判定一个数据类型中的某一方法实现了某个接口类型中的某一方法
