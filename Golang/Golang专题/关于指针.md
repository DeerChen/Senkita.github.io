# 关于指针

## 什么是指针？

1. 指针式指向某个确切内存地址的值
2. `Go`内建数据类型`uintptr`是个数值类型，根据计算机架构的不同，可以存储 32 位或 64 位无符号整数来表示指针
3. `Go`标准库`unsafe/Pointer`可以表示任何只想可寻址(`addressable`)的值的指针

## 什么是不可寻址？

不可寻址无法用取值操作符`&`获取指针。

1. 常量的值、基本类型值的字面量、函数和方法字面量、对字符串变量的索引表达式和切片表达式的结果值，会被存储到确切的内存区域中，其值不可变，所以不可寻址
2. 算术操作的结果值、类型转换和类型断言表达式的结果值、对各种字面量的索引表达式和切片表达式的结果值、函数和方法的调用表达式的结果值、对结构体字面量的选择表达式的结果值、接收表达式的结果值是一种临时结果，在将结果值赋值给任何变量之前，取得其内存地址毫无意义，所以不可寻址
3. 对字典变量的索引表达式的结果值不是临时结果，但也无法寻址，因为其键值对存储位置可能发生变动，外界无法感知，获取其指针不安全，所以不可寻址
4. 自增自减语句和赋值操作符左边的表达式的结果值必须可寻址，但对字典字面量和字典变量索引表达式的结果值例外
5. 对切片字面量的索引结果值却是可寻址的，因为底层数组的元素有确切内存地址
6. 如果将临时结果赋给一个变量，则可寻址，指针指向变量所持有的值
7. 带有`range`的`for`语句中，表达式左边的结果值要可寻址

## unsafe.Pointer

`unsafe.Pointer`可以绕过`Go`语言的编译器和其他工具检查，嵌入内存修改数据，很危险，慎用。

```go
package main

import (
	"fmt"
	"unsafe"
)

type Person struct {
	name string
}

func main() {
	a := Person{
		name: "Lili",
	}
	aPointer := &a

	/*
		1. 指针和unsafe.Pointer可以互转
		2. uintptr和unsafe.Pointer可以互转
		3. 指针无法和uintptr互转
	*/
	aPtr := uintptr(unsafe.Pointer(aPointer))
	// unsafe.Offsetof是获取两个值在内存中起始存储地址之间的偏移量，以字节为单位
	namePtr := aPtr + unsafe.Offsetof(aPointer.name)
	// 获取指针位置
	nameP := (*string)(unsafe.Pointer(namePtr))
	fmt.Println(nameP)
}
```
