# 并发中的其它协程同步工具

## sync.Value

1. 不能存储`nil`
2. 存储初值决定其存储类型
3. 不要存储引用类型

## sync.WaitGroup 和 sync.Once

```go
package main

import (
	"fmt"
	"sync"
)

var (
	// 仅用原子操作实现并发等待组
	wg sync.WaitGroup
	// 用原子操作和互斥锁实现执行一次
	oc sync.Once
)

func main() {
	count := 3
	// 计数器限制执行协程数，需要事先知道所需执行的协作流程数
	wg.Add(count)
	for i := 0; i < 5; i++ {
		go func() {
			// 计数器减一
			wg.Done()
		}()
	}
	// 当计数器归零时结束执行
	wg.Wait()

	// 同一个Once值的Do方法智慧执行第一次被调用时传入的参数函数，无论该函数会以怎样的方式结束，只有当该参数函数执行完毕之后，调用该方法的协程才会逐一被唤醒。
	oc.Do(func() {
		fmt.Println("Once")
	})
}
```

## context.Context

```go
package main

import (
	// 值可以被任意扩散，还可以被用来传递额外信息和信号，且并发安全。
	"context"
	"fmt"
	"sync/atomic"
	"time"
)

func main() {
	var num int32

	// 调用协程数取决于循环数
	total := 4
	// Context值全局唯一，即根节点
	// 根节点不提供任何额外功能，不能被撤销，也不携带数据
	root := context.Background()
	// cxt是一个可撤销的值，cancalFunc是一个撤销函数
	cxt, cancelFunc := context.WithCancel(root)

	for i := 1; i <= total; i++ {
		// 匿名函数用于判定触发撤销函数
		go addNum(&num, i, func() {
			if atomic.LoadInt32(&num) == int32(total) {
				// 手动撤销
				// DeadlineExceeded为过期撤销
				cancelFunc()
			}
		})
	}
	// Done方法返回一个元素类型为struct{}的接收通道
	// 一旦Context值被撤销，则通道关闭
	<-cxt.Done()
}

func addNum(numP *int32, id int, deferFunc func()) {
	defer func() {
		deferFunc()
	}()
	for i := 0; ; i++ {
		currNum := atomic.LoadInt32(numP)
		newNum := currNum + 1
		time.Sleep(time.Millisecond * 500)

		if atomic.CompareAndSwapInt32(numP, currNum, newNum) {
			fmt.Printf("The number: %d [%d-%d]\n", newNum, id, i)
			break
		} else {
			fmt.Printf("The CAS operation failed. [%d-%d]\n", id, i)
		}
	}
}
```

撤销信号传递深度优先。
撤销函数被调用之后，对应的`Context`值会先使用`Done`方法关闭它内部的接收通道。接着往它的所有子节点传递撤销信号，最后`Context`值会断开与其父值的关联。
`context.WithValue`函数得到的`Context`值无法撤销，撤销信号传播时，遇到它们则直接跨过，并尝试传递信号给它们的子值。

```go
package main

import (
	"context"
	"fmt"
)

type key int

func main() {
	keys := []key{
		10,
		20,
		30,
	}
	vals := []string{
		"10",
		"20",
		"30",
	}

	root := context.Background()
	node1, cancelFunc1 := context.WithCancel(root)
	defer cancelFunc1()

	// Context接口没有提供改变数据的方法，只能通过添加含数据的Context值或撤销该值的父值来增删数据
	node2 := context.WithValue(node1, keys[0], vals[0])
	node3 := context.WithValue(node2, keys[1], vals[1])
	fmt.Println(node3.Value(keys[0]), node3.Value(keys[1]), node3.Value(keys[2]))
}
```

## 临时对象池 sync.Pool

临时对象即不需要持续使用的某一类值，可以在任何时候创建和销毁，完全不会影响到程序的功能。
临时对象池可以被当作针对某种数据的缓存。
`Go`语言运行时，系统中的垃圾回收器，在每次开始执行之前会对所有创建的临时对象池中的值进行全面清除。
首先`sync`包初始化时，会向运行时系统注册一个池清理函数。`sync`有个包级私有全局变量，池汇总列表。
池清理函数会先遍历池汇总列表，先将池中的私有临时对象和共享临时对象列表置为`nil`，然后再将池中所有本地池列表销毁，最后将池汇总列表重置为空切片。然后在稍后的垃圾回收中，临时对象池会被当作垃圾销毁，所占用的内存空间也将会被回收。
临时对象池顶层时本地池列表，长度与调度器中的`processor`数相同，用于分散存储压力和性能压力。临时对象池的`Put`和`Get`方法会获取到哪一个本地池，取决于调用它的代码所在的`goroutine`关联的调度器。
本地池列表中的每个本地池包含存放私有临时对象的字段`private`、代表共享临时对象列表字段`shared`和一个`sync.Mutex`类型的嵌入字段。
`Put`方法总会先尝试把新的临时对象存储到对应本地池的`private`字段中，只有在`private`已存在某个值时，才会去访问`shared`字段，`Get`方法同理，只有`private`字段中的值为`nil`时，才会去访问`shared`字段。
`shared`字段是共享的，受互斥锁保护。
如果获取不到，将会调用可创建临时对象的`New`函数，需要初始化时给定，否则返回`nil`。

## sync.Map

`Go`自带的字典类型`map`并不是并发安全的，同一时间段内，让不同协程对同一字典进行读写操作可能会出问题。
并发安全字典的键不能是函数、字典或切片类型。因为这些的实际类型得到运行期间才能确定，编译器无法在编译时进行检查。
其次还得保证键的类型可判等，拿不准可以用`reflect.Typeof`得到键值对应的反射类型值，再调用`Comparable`方法。

### 如何保证并发安全字典中的键值类型正确性？

重载增删改查方法。

1. 只存某种特定类型值
2. 封装时候限定键值类型为`reflect.Type`，然后在方法中判等

### 并发安全字典如何尽量避免使用锁？

`sync.Map`类型中只读字典`read`字段相当于一个快照，将值转化为`unsafe.Pointer`类型存储。只读字典是逻辑删除。
当并发安全字典访问只读字典时不需要锁，只有在只读字典中没有，脏字典里可能有时，才会在锁的保护下去读取`dirty`字段。
