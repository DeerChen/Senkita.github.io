# 关于容器

## 数组与切片

1. 数组和切片都是集合类，但数组是值类型，切片是引用类型，切片是对底层数组的片段引用
2. 数组长度固定，须在声明时给定，长度是其类型属性的一部分。而切片可变长，不过不会变短
3. 引用类型的传递成本低于值类型
4. 切片的容量(`cap`)为底层数组从切片起始索引到末尾的长度，因为切片可以向右扩展
5. 切片扩容并不会改变原切片，而是生成容量更大的切片，然后将原元素和新元素一并拷贝到新切片中。新切片的容量默认为原来的 2 倍，如果原切片长度大于 1024 时，则新切片容量为原切片容量的 1.25 倍，如果一次追加元素过多，新切片的容量即等于新切片长度
6. 底层数组永远不会被替换，在扩容时生成新的底层数组，也同时生成新切片

## 链表

```go
package main

import (
    "container/list"
    "container/ring"
    "fmt"
)

var (
    // 双向链表，零值长度为0，根元素不是有任何元素值
    // 两个包级私有字段：一个是Element类型的root根元素，一个int类型的len
    // 公开字段Value，持有元素实际值
    l list.List
    // 循环链表，零值长度为1，初始化后长度不可变
    r ring.Ring
)

func main(){
    // 算法复杂度为O(N)
    fmt.Println(l.Len())
    // 算法复杂度为O(1)
    fmt.Println(r.Len())
}
```

延迟初始化机制能分散初始化操作带来的计算量和存储空间的消耗。

## 字典

字典是一种哈希表(`hash table`)的特定实现，其中`key`类型受限，而`value`的类型任意。
字典键值类型不能是函数、字典、切片类型，因为`Go`规定键值之间要能支持判等操作，而这些类型不支持。因而求哈希和判等操作速度越快的类型越适合做键值类型。
如果键类型为接口或数组类型，它的实际类型也不能是这三种，但不要将字典的键值设置成为这两种类型，因为类型存在变数，要时刻保证代码的可控性。

```go
package main

import (
    "fmt"
)

var (
    // 值为nil的字典
    dict map[string]int
)

func main(){
    // 值为nil的字典在添加元素操作时会抛出panic，但在进行其他操作时不会报错
    dict["one"] = 1
}
```

### 什么是哈希值？

哈希值通常是个无符号整数，哈希表会持有一定数量的哈希桶(`bucket`)均匀存储键值对。
哈希碰撞即不同值的哈希值可能相等。

### 字典是如何索引的？

1. 先将查找键值使用哈希函数(hash function)转换成哈希值
2. 哈希表先用哈希值的低几位去定位哈希桶，然后再去桶中查找对应键，然后将结果返回
