# 关于异常捕获

```go
package main

import (
	"fmt"
	"os"
	"os/exec"
)

// error是内建接口类型
func printError(i int, err error) {
	// 对已有相关变量且类型相同的错误值，使用判等
	if err == nil {
		fmt.Println("nil error")
		return
	}

	err = underlyingError(err)

	// 对没有相关变量且类型位置的错误值，只能使用其错误信息字符串表示
	switch err {
	case os.ErrClosed:
		fmt.Printf("error(Closed)[%d]: %s\n", i, err)
	case os.ErrInvalid:
		fmt.Printf("error(Invalid)[%d]: %s\n", i, err)
	case os.ErrPermission:
		fmt.Printf("error(Permission)[%d]: %s\n", i, err)
	}
}

func underlyingError(err error) error {
	// 对已知范围内的潜在错误值，使用类型switch语句
	switch err := err.(type) {
	case *os.PathError:
		return err.Err
	case *os.LinkError:
		return err.Err
	case *os.SyscallError:
		return err.Err
	case *exec.Error:
		return err.Err
	}
	return err
}
```

## panic

代码触发`panic`，初始`panic`详情被建立，控制权转移至调用栈的上一级，这意味着代码所属函数执行终止，然后控制权依次沿调用栈反向传播至顶层(最外层函数)，然后被`Go`语言系统收回，随即程序崩溃并终止运行，承载程序此次运行的进程消亡。在控制权传播过程中，`panic`详情被积累完善，并在程序终止之前被打印出来。

```go
package main

import (
	"errors"
	"fmt"
)

func main() {
	// 延迟调用，将会在函数结束前执行
	// 如果有多条defer语句，调用顺序由下至上，因为defer队列是FILO的
	defer func() {
		// 用于平息恐慌，并返回一个interface{}，其中包含引发的panic的值
		if p := recover(); p != nil {
			fmt.Printf("panic: %s", p)
		}
	}()

	// Go语言提供内建函数panic用来处理不致命异常
	// 唯一参数是interface{}
	panic(errors.New("Err"))
}
```
