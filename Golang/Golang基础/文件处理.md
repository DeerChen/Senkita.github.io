# 文件处理

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"io/ioutil"
)

func main() {
	filePath := "demo.txt"
	createFile(filePath)

	file, _ := os.OpenFile(filePath, os.O_WRONLY | os.O_APPEND, 0666)
	defer file.Close()

	writer := bufio.NewWriter(file)
	writer.WriteString("Halo")
	// writer是带缓存的，调用方法时，其实是先写入缓存，所以需要调用Flush方法，将数据写入到文件中
	writer.Flush()

	data, _ := ioutil.ReadFile(filePath)
	fmt.Println(data)
}

func createFile(filePath string) {
	// 创建文件，返回文件和错误值
	// 已经存在的文件不能使用Create
	f, err := os.Create(filePath)
	if err != nil {
		return
	}

	// 写入数据，返回写入长度和错误值
	WSLength, _ := f.WriteString("Halo")
	WLength, _ := f.Write([]byte("World"))
	s, _ := f.Seek(0, os.SEEK_END)
	WALength, _ := f.WriteAt([]byte("!\n"), s)
	fmt.Println(WSLength, WLength, WALength)

	defer f.Close()
}
func readFile(filePath string) {
	f, err := os.Open(filePath)
	if err != nil {
		return
	}
	defer f.Close()
	buffer := make([]byte, 2*1024)
	length, err := f.Read(buffer)
	if err != nil && err == io.EOF {
		return
	}
	fmt.Println(string(buffer[:length]))
}

func readLines(filePath string) {
	f, _ := os.Open(filePath)
	r := bufio.NewReader(f)
	for {
		// 遇到换行结束
		buffer, err := r.ReadBytes('\n')
		if err != nil && err == io.EOF {
			break
		}
		fmt.Println(string(buffer))
	}
	defer f.Close()
}

func pathExists(filePath string) (bool, error) {
	_, err := os.Stat(filePath)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, nil
	}
	return false, nil
}
```

## os.Args 和 flag 包

`os.Args`用于记录命令行参数的字符串数组。`flag`包用来解析命令行参数。

```go
package main

import "flag"

// 定义变量用于接收命令行参数值
var port int

func main() {
	flag.IntVar(&port, "port", 3306, "端口号")
	// 转换
	flag.Parse()
}
```
