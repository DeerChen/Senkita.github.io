# 面向对象

面向过程强调步骤过程。尽量在程序内减少匿名组合，否则会增加复杂度。
`Go`语言中没有继承、重载(方法名一致，参数类型或个数不一致)。
封装(`encapsulation`)，将抽象出来的字段和对字段的从左封装在一起，数据被保护在内部，程序的其他包只有通过被授权的操作，即方法，才可以对字段进行操作。封装可以隐藏实现细节，对数据进行验证以确保安全合理。

```go
package main

import (
	// JavaScript Object Notation，在网络传输中，程序将对象序列化成JSON字符串，接收方将JSON字符串反序列化成对象。
	"encoding/json"
	"fmt"
)

// 结构体的所有字段在内存中是连续的
type Person struct {
	name string `json:"name"` // tag可以通过反射机制获取，常用于序列化和反序列化
}

type Student struct {
	// Go语言中通过匿名组合嫁接功能
	// 匿名组合只有类型没有名称
	Person
	// 如遇同名字段，则有屏蔽现象
	learn func(string)
}
type Mentor struct {
	*Person
}

// 接口只有声明，没有实现，由类型去实现
// 接口用于实现多态
type Teacher interface {
	teach(string)
	eat()
}

var (
	t       Teacher
	teacher Mentor
	p       Person
)

func main() {
	human := Person{
		"human",
	}
	// 序列化
	jsonStr, _ := json.Marshal(&human)
	fmt.Println(string(jsonStr))

	// 反序列化
	err := json.Unmarshal(jsonStr, &p)
	if err != nil {
		fmt.Println(err)
	}

	student := Student{
		Person: Person{
			name: "Lili",
		},
		learn: demo,
	}

	fmt.Println(student.Person.name)

	// 指针类型匿名字段需要指向，否则无法使用
	// new是分配空间，返回指针类型
	teacher.Person = new(Person)
	teacher.Person.name = "Confucius"

	// 只要结构体实现对应接口，则根据该结构体创建的对象，可以赋值给对应接口类型
	// 接口可以超集转子集
	t = &Mentor{}
	t.teach("teach")
}

func demo(str string) {
	fmt.Println(str)
}

// 方法，有接收者声明
// 方法的类型要用类型别名
func (t *Mentor) teach(str string) {
	demo(str)
}

// 同名方法重写
func (t *Mentor) eat() {
	demo("eat nice")
}
```
