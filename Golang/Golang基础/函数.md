# 函数

将可重用代码进行封装。
函数的默认值传递，即传参数副本，函数内改动不影响原值。
每个源文件中都可包含一个`init`函数，将会在`main`函数执行前被调用。全局变量定义在`init`函数之前执行。

```go
package main

import "fmt"

func main() {
	add(1, 2)
	// 固定参数必须传值
	sum(0, 1, 2, 3, 4, 5)
	fmt.Println(factorial(10))
}

// 普通参数列表
func add(a, b int) (int, error) {
	// 函数嵌套
	// 匿名函数
	f := func() {
		fmt.Printf("%d+%d=%d\n", a, b, a+b)
	}
	f()
	// 多返回值
	return a + b, nil
}

// 不定参数列表只能放在形参最后一位
// 不定参数列表可以视需要传值
func sum(num int, args ...int) int {
	for i := 0; i < len(args); i++ {
		num += args[i]
	}
	return num
}

// 递归函数
// 每执行一个函数，就创建一个新的受保护独立空间(新函数栈)。谁调用就把结果返回给谁
// 要有终止量和渐变量
func factorial(num int) int {
	if num == 1 {
		return 1
	}
	return num * factorial(num-1)
}
```

## 作用域

定义在函数外部的变量就是全局变量，函数内部的即是局部变量。同名局部变量会屏蔽全局变量，所以要尽可能避免重名。

## 闭包

闭包`Closure`是一个函数和与其相关的引用环境组合而成的一个实体。

```go
package main

import (
	"fmt"
)

func main() {
	fn := closure()
	fmt.Println(fn(1))
	fmt.Println(fn(1))
	fmt.Println(fn(1))
}

func closure() func(int) int {
	n := 0
	// 返回出来的函数与它所引用到的变量共同形成闭包
	return func(x int) int {
		n += x
		return n
	}
}
```
