{"./":{"url":"./","title":"全栈养成计划","keywords":"","body":"全栈养成计划 [info] For Info 参考用时仅粗略估算理论学习时间，项目实践不计入其中 通用 Get 课程安排 参考用时 达成目标 √ Linux基础+Git 1d 会用Linux基本指令，规范使用Git服务器[1]，了解Git Flow √ Markdown+LaTex 1d 会编写文档，能用LaTex编写公式 关系型数据库[2] 2d 能用SQL语句增删改查 非关系型数据库[3] 2d 会增删改查 Docker 1d 会使用容器 √ 正则表达式 1d 会正则表达式提取 部署网站服务器+CICD 2d 能上线项目，并实现DevOps PhotoShop 1d 会切个图就行 数据结构与算法[4] / 会解算法题 计算机基础[5] / 了解基础知识 [1] Git服务器：Github、BitBucket、Gitee、GitLab等 [2] 关系型数据库：MySQL(MariaDB)、SQLite3、PostgreSQL等 [3] 非关系型数据库：Redis、MongoDB、HBase等 [4] 数据结构与算法：线性表、栈、队列、树、图等 [5] 计算机基础：组成原理、计算机网络、操作系统等 前端 Get 课程安排 参考用时 达成目标 √ HTML5 1d 能写静态网页骨架 √ CSS3+Less 1d 会用各种布局，能写静态网页样式 TypeScript基础[1] 1d 能写TypeScript脚本 ES6+TypeScript进阶[2] 1d 理解EMCAScript和TypeScript特性 AJAX+axios+Mock.js 1d 了解AJAX，会用axios异步拉取数据，会Mock数据 跨域+鉴权 1d 了解Cookies和Session，会OAuth2鉴权 jQuery+Zepto.js 1d 能操作DOM，写出完整静态网页 Webpack+Vue.js基础 2d 会用包管理工具yarn或npm，能建Vue3框架，了解项目结构 Vue.js进阶 1d 能写简单Vue3项目 VueRouter+Vuex[3] 2d 会用路由管理和状态管理，能上手Vue3工程项目 ReactJS 2d 会TSX语法 Router+Redux[4] 2d 会路由管理和状态管理，能上手ReactJS工程项目 测试框架[5] 2d 会写单元测试 小程序开发框架[6] 3d 能开发小程序 跨端框架[7] 4d 能做跨端应用 [1] TypeScript基础：作用域、类型、变量与常量、函数、循环判断等 [2] TypeScript进阶：类(面向对象编程)、闭包、Promise、Proxy等 [3] Vuex：Vue3有了Hooks，甚至可以不用Vuex做状态管理 [4] Redux：ReactJS有了Hooks，已经可以不用Redux做状态管理了 [5] 测试框架：Jest、Mocha等 [6] 小程序开发框架：Taro、mpvue、WePY等 [7] 跨端框架：React Native、Vue Native等 后端 Python Get 课程安排 参考用时 达成目标 Python基础 2d 能写Python脚本，会OOP Python进阶[1] 1d 再会些奇技淫巧 数据库 1d 能用Python操作数据库 爬虫[2] 2d 会解析网页，能爬取资源，能应付基本反爬 网络开发框架[3] 4d 能搭建RESTful接口 数据分析框架[4] 4d 能产出数据分析可视化报告 机器学习[5] / 深耕人工智能领域 [1] Python 进阶：多线程、多进程、异常处理等 [2] 爬虫：Requests、Selenium、requests-html、BeautifulSoup等 [3] 网络开发框架：Flask、Django、FastAPI等 [4] 数据分析框架：Pandas、Numpy、Scipy、Matplotlib等 [5] 机器学习：Tensorflow等 Golang Get 课程安排 参考用时 达成目标 √ Golang基础 2d 能写Golang脚本 √ Golang进阶 1d 会文件处理等 √ 测试框架[1] 1d 会写单元测试 数据库 1d 能用Golang操作数据库 网络编程基础 1d 了解服务器基本原理 网络开发框架[2] 4d 能搭建RESTful接口 区块链技术 / 深耕区块链领域 Kubernetes / 深耕微服务容器化领域 [1] 测试框架：goConvery等 [2] 网络开发框架：Gin、Beego、Iris等 Node.js Get 课程安排 参考用时 达成目标 Node.js 1d 能写Node.js脚本 数据库 1d 能用Node.js操作数据库 网络开发框架[1] 4d 能搭建简单服务器 [1] 网络开发框架：Express.js、Egg.js、Koa.js等 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Linux基础/":{"url":"Linux基础/","title":"Linux 基础","keywords":"","body":"Linux 基础 链接 Linux内核开源仓库 RedHat 系 CentOS官网 CentOS搜狐镜像 CentOS网易镜像 Debian 系 Debian官网 Debian网易镜像 Ubuntu官网 专题讨论 Linux 是什么？ Linux是个操作系统，由 Linus 开源，与世界各地的Linux爱好者共同开发。Linus 现在主要做代码审查和功能裁定工作。 Linux 和 Unix 什么关系？ Linux是类Unix系统 系统 Unix Linux 价格 商业软件 开源软件 适用平台 硬件配套 多平台 系统结构 内核层：调控系统资源 Shell层：终端(Terminal) 应用层：图形界面(但服务器不用，因为图形化占资源) Linux 有啥用？ 嵌入式系统：手机、平板 服务器 Linux 版本阵营 阵营 RedHat系 Debian系 版本 RedHat、CentOS等 Debian、Ubuntu等 安装工具 yum apt © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Linux基础/Linux目录.html":{"url":"Linux基础/Linux目录.html","title":"Linux 目录","keywords":"","body":"Linux 目录 ~/$ tree / -L 1 / ├── bin：(binaries)保存系统命令，所有用户都可执行 ├── boot：系统启动目录 ├── dev：(devices)存放设备文件 ├── etc：(etcetera)存放系统配置文件 ├── home：存放普通用户的相关文件 ├── lib：存放系统程序运行所需共享库 ├── media：挂载软盘或光驱 ├── mnt：(mount)挂载临时文件系统 ├── opt：存放第三方软件 ├── proc：虚拟文件系统，存放当前进程信息 ├── root：root用户的主目录 ├── sbin：(super user binaries)保存和系统环境设置相关的命令，只有超级用户可用，部分命令允许普通用户查看 ├── srv：服务数据目录 ├── sys：虚拟文件系统，存放内存相关信息 ├── tmp：(temporary)存放临时文件 ├── usr：(unix software resource)系统软件共享资源目录 │ ├── bin：存放系统命令，所有用户可执行 │ └── sbin：存放根文件系统不必要的系统管理命令，超级用户可执行 └── var：(variable)存放动态数据 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Linux基础/Shell命令.html":{"url":"Linux基础/Shell命令.html","title":"Shell 命令","keywords":"","body":"Shell 命令 帮助 ~/$ man ls # manual获取命令帮助信息 ~/$ help ls 文件处理 ~/$ cd . # change directory切换目录，.是当前目录，..是父级目录，~是主目录 ~/$ ls -l -a -h # list列出，-l是列表形式展示，-a是包含隐藏文件，-h是显示文件大小单位 ~/$ pwd # print working directory输出当前目录 ~/$ mkdir -p newDir # make directory新建文件夹，-p是如果父目录不存在，则一并生成 ~/$ touch README.md # 新建文件 ~/$ echo '' >> README.md # >是覆盖写入，>>是追加 > README.md`)\"> ~/$ cp -r -p dir1/ dir2/ # copy复制，-r是用于目录的递归复制，-p是保留原文件属性 ~/$ mv oldFile newFile # move移动 ~/$ rm -rf dir/ # remove删除，-r是用于目录的递归删除(recursive)，-f是强制删除(force) ~/$ ln -s file1 link1 # link创建快捷方式，-s是创建软链接 查看 ~/$ cat README.md # concatenate显示文件内容 ~/$ more README.md # 分页显示文件内容，空格显示下一页，回车显示下一行，q退出 ~/$ head -n 5 README.md # 显示头几行，-n是指定行数 ~/$ tail -n 20 README.md # 显示后几行，-n是指定行数 查找 ~/$ find dir/ -name \"demo\" -size -204800 # -name是精确按名查找，-size是按文件大小查找，+是大于，-是小于，不写是等于，以block为单位，1K=2block ~/$ find dir/ -iname \"demo?\" -type f # -iname是不区分大小写按名查找，*是匹配所有，?是匹配一个，-type是按文件类型查找，f是二进制文件，l是软链接文件，d是目录，c是字符文件 ~/$ grep -v demo -i -n -c file1 # -v是反选，-i是忽略大小写，-n是显示匹配行和行号，-c是输出匹配行次数 ~/$ which ls # 显示命令所在目录 ~/$ whereis ls # 显示命令及其配置文件和帮助文档的所在目录 磁盘操作 ~/$ df -h -m -a # 显示文件系统状态，-h是(human-readable)以易读方式显示，-m是以MB为单位，-a是显示所有分区 ~/$ du -h -a -s /home # 只显示占有空间，-h是(human-readable)以易读方式显示，-a是显示所有分区，-s是(summarize)统计总占有量 ~/$ free -g # 显示内存使用率，-g是以GB为单位 解压缩 ~/$ tar -zcvf dir1.tar.gz dir/ # -c是压缩成tar格式，-z是压缩成gzip格式(不支持压缩目录)，-v是显示过程，-f是指定压缩文件名(必须有且必须放最后) ~/$ tar -C /opt -xjf dir1.tar.bz2 # -C是解压到指定目录，-x是解压tar格式，-j是解压bzip2格式 ~/$ zip -r dir1.zip dir1/ # -r是压缩目录 ~/$ unzip file1.zip # 解压zip格式 系统 ~/$ date # 显示系统时间 ~/$ shutdown -c -h 21:30 -r # 关机，-c是取消上一个关机命令，-h是指定时间，-r是重启 ~/$ reboot # 重启 ~/$ uname -r # 查看系统版本信息 网络 ~/$ ping baidu.com # 测试网络连通性，ping使用ICMP协议，不占用端口 ~/$ ip addr # 查看网卡信息 ~/$ ifconfig -a # interface configure，需要装net-tools，-a是查看所有网卡 ~/$ netstat -antup # network statistics检测主机网络配置，-a是查看所有连接和监听端口，-n是以数字方式显示地址和端口号，-t是显示tcp协议相关，-u是显示udp协议相关，-p是显示socket的PID和进程名 进程管理 进程和线程 进程是系统进行资源分配和调度的基本单位 线程是程序执行的最小单元 / 进程 线程 定义 程序的执行过程 轻量级进程，由进程创建 地址空间 有独立地址空间 没独立地址空间 资源消耗 CPU和内存耗费小于进程 ~/$ ./install.sh & # &是后台进程标识，但仅支持非交互式命令 ~/$ ps aux # 查看进程信息，a是显示所有用户进程，u是显示用户名和启动时间，x是显示没有终端的进程 ~/$ ps -le # -l是长格式显示，-e是显示所有进程 ~/$ top -d 5 # 查看系统健康状态，-d是刷新秒数 ~/$ kill -9 1024 # 关闭进程，-9是强制关闭 ~/$ kill -1 1024 # -1是重启 ~/$ killall -l # 关闭所有 ~/$ w root # 查看用户信息 ~/$ nohup ping baidu.com & # 挂起，即使用户退出登录依旧继续执行 ~/$ uptime # 查看负载 文件权限 # 第1位是文件类型，d是目录，-是普通文件，l是链接文件 # 第2-4位是所属用户权限，第2-4位是所属用户组权限，第2-4位是其它用户权限 # r是(read)读，w是(write)写，x是(execute)执行 -rwxr--r-x ~/$ chmod -R 777 README.md # change mode修改权限，-R是递归修改，r=4，w=2，x=1 ~/$ chown -R root:root README.md # change file ownership修改所有者，-R是递归修改 ~/$ chgrp root README.md # change file group ownership修改所属组 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Linux基础/Linux用户权限.html":{"url":"Linux基础/Linux用户权限.html","title":"Linux 用户权限","keywords":"","body":"Linux 用户权限 Linux支持多用户同时登陆系统使用资源 配置文件 ~/$ tree /etc -L 1 /etc/ ├── passwd：保存用户信息 ├── shadow：保存密码 ├── group：保存用户组 └── gshadow：保存用户组密码 /etc/passwd # 用户名:密码:UID(用户标识号):GID(缺省组标识号):描述信息:主目录:Shell root:x:0:0:root:/root:/bin/bash /etc/shadow # 用户名:加密密码:最后一次修改时间:改密最小时间间隔:密码有效最大天数:经过密码失效天数:密码过期宽限天数:失效天数:标志 # 加密密码为*表示没有密码，为!!无法登录 root:*:17757:0:99999:7::: /etc/group # 组名:组密码:组标识号:组内成员 root:x:0: /etc/gshadow # 组名:组密码:组管理员用户:组附加成员 root:*:: 常用命令 ~/$ whoami # 查看当前用户 ~/$ id demo # 查看指定用户的UID和GID ~/$ groups # 查看当前用户组 ~/$ exit root # 退出用户 ~/$ su root # 切换用户 ~/$ useradd -u 500 -g sys -c \"demo\" demo # 添加用户，-u是指定UID，-g是指定用户组，-c是用户描述 ~/$ useradd -G sys,root demo # -G是指定多个用户组 ~/$ passwd demo # 修改密码 ~/$ passwd -S demo # 查看密码状态，仅root可用 ~/$ usermod -g sys # user modify修改用户，-g是指定组 ~/$ userdel -r demo # user delete删除用户，删除用户时，如同名初始组为空，会一并删除同名初始组，-r是删除用户同时删除用户主目录 ~/$ groupadd -g 1024 demo # 添加组 ~/$ groupmod -n newGroup oldGroup # 修改组名 ~/$ groupdel -g 1024 # 删除组 专题讨论 Linux 中有哪几类用户？ 超级用户：root，UID=0 普通用户：UID范围在 500-60000 伪用户：UID范围在 1-499 什么是伪用户？ 伪用户与系统和程序服务相关，如系统默认有bin、daemon等，程序自建的有apache、mysql、sshd等 伪用户通常不需要也无法登录系统 可以没有主目录 用户和用户组 用户登录即有初始组，附加组可以多个 用户组内可以有多个用户，组内用户拥有组的权限 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Linux基础/Linux常用软件.html":{"url":"Linux基础/Linux常用软件.html","title":"Linux 常用软件","keywords":"","body":"Linux 常用软件 VIM 文本编辑器，其它常用的还有nano、gedit等 ~/$ sudo apt install vim # 安装vim ~/$ x # 删除字符 ~/$ d # 删除行 ~/$ dd # 剪切 ~/$ yy # 复制 ~/$ p # 粘贴 ~/$ i # 进入编辑模式 ~/$ :wq! # w是保存，q是退出，!是强制 SSH 远程连接 ~/$ ssh-keygen -t rsa -f id_rsa -C demo@example.com # 生成密钥，公钥放远端。公钥位置：Windows在%USERPROFILE%.ssh\\id_rsa.pub，Unix在~/.ssh/id_rsa.pub。-t是指定密钥类型，可以是rsa也可以是ed25519，-f是指定文件名，-C是识别密钥注释 ~/$ scp -r dir/ root@192.168.1.1:/root/demo # 传输文件，-r是针对目录传输 Screen 终端分屏 ~/$ sudo apt install screen # 安装screen ~/$ screen -ls # 列出所有终端 ~/$ screen -wipe # 清理无效终端 ~/$ screen -S demo # 新建终端 ~/$ screen -r demo # 恢复终端 ~/$ screen -X -S 123 quit # 退出终端 防火墙 ~/$ sudo apt install ufw # 安装防火墙 ~/$ sudo systemctl enable ufw # 开机自启 ~/$ sudo ufw default deny # 设置规则，默认拒绝 ~/$ sudo ufw allow \"Nginx Full\" # 允许应用 ~/$ sudo ufw allow 3306 # 允许端口 ~/$ sudo ufw delete ssh # 删除规则 Aria2 下载器 ~/$ sudo apt install libgnutls28-dev nettle-dev libgmp-dev libssh2-1-dev libc-ares-dev libxml2-dev zlib1g-dev libsqlite3-dev pkg-config libcppunit-dev autoconf automake autotools-dev autopoint libtool git gcc g++ libxml2-dev make quilt # 安装依赖项 ~/$ git clone https://github.com/aria2/aria2.git ~/$ cd aria2 ~/aria2$ sudo autoreconf -i # 编译安装，执行 autoconf、automake，生成 configure 文件 ~/aria2$ sudo ./configure # 生成 Makefile、config.h，检测依赖库是否完全 ~/aria2$ sudo make && sudo make install # 安装 Crontab 定时器 ~/$ service crond start # 启动服务 ~/$ service crond stop # 停止服务 ~/$ service crond restart # 重启服务 ~/$ service crond reload # 重载配置 ~/$ service crond status # 查看服务状态 ~/$ crontab -e # 打开配置 # 格式是分(0-59) 小时(0-23) 天(1-31) 月(1-12) 周几(0-6) * * * * * echo \"Halo\" ProxyChains 代理 ~/$ sudo apt install proxychains # 安装ProxyChains ~/$ sudo vi /etc/proxychains.conf socks5 127.0.0.1 10808 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Linux基础/Linux常用配置.html":{"url":"Linux基础/Linux常用配置.html","title":"Linux 常用配置","keywords":"","body":"Linux 常用配置 Sudo ~/$ sudo vi /etc/sudoers # 授权用户 主机=(切换到:是否需要密码) 可用命令 # 括号内容可省略 root ALL=(ALL:NOPASSWD) ALL 改源 ~/$ sudo vi /etc/apt/sources.list Debian # 改为网易源 deb http://mirrors.163.com/debian/ buster main deb http://mirrors.163.com/debian/ buster-updates main deb http://mirrors.163.com/debian-security/ buster/updates main Ubuntu # 163源 deb http://mirrors.163.com/ubuntu/ Groovy main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ Groovy-security main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ Groovy-updates main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ Groovy-proposed main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ Groovy-backports main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ Groovy main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ Groovy-security main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ Groovy-updates main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ Groovy-proposed main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ Groovy-backports main restricted universe multiverse # 阿里云源 deb http://mirrors.aliyun.com/ubuntu/ Groovy main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ Groovy-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ Groovy-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ Groovy-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ Groovy-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ Groovy main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ Groovy-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ Groovy-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ Groovy-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ Groovy-backports main restricted universe multiverse # 清华源 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ Groovy main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ Groovy main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ Groovy-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ Groovy-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ Groovy-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ Groovy-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ Groovy-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ Groovy-security main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ Groovy-proposed main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ Groovy-proposed main restricted universe multiverse © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Git/":{"url":"Git/","title":"Git","keywords":"","body":"Git 链接 Git 官网 Git 服务器 GitHub官网 GitLab官网 BitBucket官网 Gitee官网 可视化工具 SourceTree官网 SmartGit官网 专题讨论 Git 是什么？ Git是 Linus(没错，又是他)开源的分布式版本控制工具。 版本控制工具有哪些？ 集中型：svn、cvs、vss等，对中央仓库依赖严重，且上传都是完整版，不好溯源，不易多版本协同 分布式：BitKeeper、Git等 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Git/Git常用命令.html":{"url":"Git/Git常用命令.html","title":"Git 常用命令","keywords":"","body":"Git 常用命令 基本设置 ~/$ sudo apt install git # 安装 ~/$ git init # 初始化 ~/$ ssh -T git@github.com # 测试Github的ssh连接 ~/$ git config --global user.name \"name\" # 设置信息，因为分布式版本控制，所以需要有用户名和邮箱做标识 ~/$ git config --global user.email \"email@example.com\" 版本控制 上传下载 ~/$ git status # 查看文件状态 ~/$ git log # 查看历史 ~/$ git add . # 提交到暂存区 ~/$ git commit -am \"Add files\" # 提交到版本库，-a是添加所有改动代码，-m是添加描述 ~/$ git push -u origin main # 推送到远程仓库，-u是标识默认提交仓库和分支 ~/$ git remote add origin git@github.com:demo/example.git # 关联项目地址 ~/$ git remote set-url origin git@github.com:demo/example.git # 设置项目地址 ~/$ git remote rm origin # 删除已关联项目地址 ~/$ git clone https://github.com/demo/example.git # 克隆到本地 ~/$ git pull https://github.com/demo/example.git # 从远程仓库拉取并合并 ~/$ git fetch https://github.com/demo/example.git # 从远程仓库拉取 分支管理 ~/$ git branch # 查看分支 ~/$ git branch develop # 创建分支 ~/$ git checkout develop # 切换分支 ~/$ git branch -d develop # 删除分支 ~/$ git merge develop # 合并分支，保留commit历史 ~/$ git rebase -i develop # 不保留commit历史，慎用 ~/$ git diff main develop # 查看区别 撤销改动 ~/$ git stash # 将撤销代码暂存 ~/$ git checkout develop # 释放暂存的代码到其他分支上去 ~/$ git stash pop ~/$ git checkout develop # 嫁接改动到正确分支 ~/$ git cherry-pick 0d934b3 --no-commit # --no-commit是不commit，只放暂存区，支持同时嫁接多个改动 ~/$ git reflog # 恢复撤销 未提交到暂存区 即未add，撤回到上一次add或commit时的状态 ~/$ git checkout -- README.md # 撤销单个文件 ~/$ git checkout . # 撤销全部改动 提交到了暂存区 即已经add，但未commit ~/$ git rm --cached 文件名 # 放弃指定文件的暂存 ~/$ git rm --cached -r . # 放弃全部文件的暂存 提交到了版本库 即已经commit，但未push到远程 ~/$ git reset HEAD^ # 撤销错误提交的commit到工作区 ~/$ git reset --mixed HEAD~1 # 退回一次提交改动到工作区 ~/$ git reset --soft HEAD~1 # 退回一次提交改动到暂存区 ~/$ git reset --hard HEAD^ # 直接硬核回退到上一个commit 提交到了远程仓库 即已经push过了，只能用一次新 commit 去撤回一次提交 ~/$ git revert HEAD --no-edit # 直接硬核回退到上一个commit，--no-edit是直接使用默认Commit Messages ~/$ git revert HEAD --edit ~/$ git revert HEAD --no-commit # 撤销改动到暂存区 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Git/Git常用操作.html":{"url":"Git/Git常用操作.html","title":"Git 常用操作","keywords":"","body":"Git 常用操作 配置文件 sudo vi ~/.ssh/config # 别名 Host gitee # 域名 Hostname gitee.com # HTTP代理 # ProxyCommand connect -H localhost:10809 %h %p User git PreferredAuthentications publickey IdentityFile ~/.ssh/gitee_rsa Host github Hostname github.com # SOCKS代理 # ProxyCommand connect -S localhost:10808 %h %p User git PreferredAuthentications publickey IdentityFile ~/.ssh/github_ed25519 自建 Git 服务器 ~/$ git init --bare demo.git # 服务器初始化 ~/$ chown -R root:root demo.git # 赋权 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Git/GitFlow工作流.html":{"url":"Git/GitFlow工作流.html","title":"GitFlow 工作流","keywords":"","body":"GitFlow 工作流 多分支协同 ~/$ brew install git-flow # 安装git-flow ~/$ sudo apt install git-flow 对比原生操作 初始化 ~/$ git flow init # 使用git-flow ~/$ git branch develop # 使用原生Git ~/$ git push -u origin develop feature 分支 用于添加功能特性 使用 git-flow ~/$ git flow feature start Feature-1 # 创建feature分支 ~/$ git flow feature publish Feature-1 # 推送feature分支到远程 ~/$ git flow feature pull origin Feature-1 # 拉取远程更新到feature分支 ~/$ git flow feature finish Feature-1 # 完成feature分支，加入develop分支，并删除feature分支 使用原生 git ~/$ git checkout -b Feature-1 develop # 基于develop分支，创建并切换到feature分支 ~/$ git push -u origin Feature-1 # 推送feature分支到远程 ~/$ git pull origin develop # 拉取远程更新到develop分支 ~/$ git checkout develop # 切换至develop分支 ~/$ git merge --no-ff Feature-1 # 将feature分支合并入develop分支，--no-ff是保存分支记录 ~/$ git push origin develop # 推送develop分支到远程 ~/$ git branch -d Feature-1 # 删除feature的本地和远程分支 ~/$ git push origin --delete Feature-1 release 分支 用于版本发布，可将改动合并入main分支和develop分支 使用 git-flow ~/$ git flow release start Release-1 # 创建release分支 ~/$ git flow release publish Release-1 # 推送release分支到远程 ~/$ git flow finish Release-1 # 完成release分支，加入develop分支和main分支，并删除release分支 使用原生 Git ~/$ git checkout -b Release-1 develop # 基于develop分支，创建并切换到release分支 ~/$ git checkout main # 切换到main分支 ~/$ git merge --no-ff Release-1 # 将release分支合并到main分支，并推送到远程 ~/$ git push origin main ~/$ git checkout develop # 切换到develop分支，将release分支合并到develop分支，并推送到远程 ~/$ git merge --no-ff Release-1 ~/$ git push origin develop ~/$ git branch -d Release-1 # 删除release的本地和远程分支 ~/$ git push origin --delete Release-1 hotfix 分支 hotfix分支基于main分支，bugfix分支基于develop分支 使用 git-flow ~/$ git flow hotfix start Hotfix-1 ~/$ git flow hotfix finish Hotfix-1 使用原生 Git ~/$ git checkout -b Hotfix-1 main # 从main分支中创建hotfix分支 ~/$ git checkout main # 完成hotfix分支 ~/$ git merge --no-ff Hotfix-1 ~/$ git push origin main ~/$ git checkout develop ~/$ git merge --no-ff Hotfix-1 ~/$ git push origin develop ~/$ git branch -d Hotfix-1 ~/$ git push origin --delete Hotfix-1 ~/$ git tag -a V1.0 -m \"New version\" main # 打标签 ~/$ git push --tags © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Git/Git规范.html":{"url":"Git/Git规范.html","title":"Git 规范","keywords":"","body":"Git 规范 Commit Message ~/$ git commit # 打开提交信息文档进行编辑 提交信息文档 # type(scope): subject 简述 build(packages.json): build the framework # body 详细描述 - Add TypeScript support # breaking changes BREAKING CHANGE: Older versions are not support any more # affect issue resolves #110, #120, #119 type 主要类型 feat：增加新功能 fix：修复bug 特殊类型 docs：文档改动 style：不改变代码含义的样式改动，如删除空格等 build：构造工具或外部依赖改动 refactor：代码重构 revert：撤销改动 test：测试相关改动 perf：性能方面改动 ci：持续集成相关改动 chore：无关紧要的改动 scope 指出改动范围，如果范围跨模块，建议分拆提交，有利于追踪维护 subject 以动词一般现在时第一人称开头，首字母小写，不加句号，50 字以内 body 以动词一般现在时第一人称开头，说明动机以及变化 Footer 只用在不兼容变动和issue处理上 breaking changes 变动描述，说明变动缘由 affect issue resolves：解决issue中的问题 closes：关闭issue fixes：修复issue中的bug 提交信息规范工具 commitizen ~/$ npm install -g commitizen cz-conventional-changelog # 安装 ~/$ commitizen init cz-conventional-changelog --save --save-exact # 使项目支持Angular的Gommit Message规范 ~/$ git cz # 替代git commit ~/.czrc { \"path\": \"cz-conventional-changelog\" } cz-conventional-changelog ~/$ npm install -g cz-conventional-changelog # 安装 ~/$ conventional-changelog -p angular -i CHANGELOG.md -w -r 0 # 生成Change Log，-p是指定规范，-i是指定文件名，-w是覆写，-r是生成全部 commitlint 和 husky commitlint提供格式校验，husky提供更易用的git hook ~/$ npm i -D husky @commitlint/config-conventional @commitlint/cli # 安装 packages.json { \"husky\": { \"hooks\": { \"commit-msg\": \"commitlint -e $GIT_PARAMS\" } } } commitlint.config.js module.exports = { extends: ['@commitlint/config-conventional'], }; README.md ## Introduction 项目介绍 ## Features 项目特性 ## To Do 项目 To do ## Installation 项目安装步骤 ## Usage 项目使用说明 ## Maintainers 项目维护者 ## License 项目许可 ## References 项目引用 ChangeLog.md # 更新日志 ## [Unreleased] ## [1.0.0] - 2020-02-02 ### Added - 新增项 1 - 新增项 1 ### Changed - 改动项 1 - 改动项 2 ### Fixed - 修复项 1 - 修复项 2 ### Removed - 移除项 1 - 移除项 2 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Git/持续集成.html":{"url":"Git/持续集成.html","title":"持续集成","keywords":"","body":"持续集成 链接 Github Actions 官方市场 awesome-actions 配置 .github/workflows/build.yaml # 工作流程名 name: build # 触发条件 on: push: # 限定分支 branches: - main # 任务 jobs: # job_id job1: # 镜像平台 runs-on: ubuntu-latest # 步骤 steps: # 步骤描述 - name: checkout main # 使用已有包 uses: actions/checkout@v2 # 改动分支 with: ref: main job2: # 执行顺序 needs: job_1 steps: - name: push remote # 步骤环境变量 env: # 在Settings-Develop settings-Personal access tokens中设置 TOKEN: ${{ secrets.TOKEN }} REF: github.com/${{github.repository}} EMAIL: demo@example.com NAME: ${{github.repository_owner}} # 执行步骤 run: | git config --global user.email \"${EMAIL}\" git config --global user.name \"${NAME}\" git init git remote add origin https://${REF} git branch -M main git push --force --quiet \"https://${TOKEN}@${REF}\" main:main © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Markdown/":{"url":"Markdown/","title":"Markdown","keywords":"","body":"Markdown 轻量级标记语言，本质就是HTML，所以兼容HTML标签，文件后缀名为.md或.markdown 链接 Typora官网 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Markdown/Markdown基础语法.html":{"url":"Markdown/Markdown基础语法.html","title":"Markdown 基础语法","keywords":"","body":"Markdown 基础语法 标题 一共 6 个，对应HTML中的到 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 图片 ![图片描述](https://www.baidu.com/img/flexible/logo/pc/result.png) ![图片描述][图片的base64值] 表格 ---：左对齐 :---:：居中对齐 ---:：右对齐 | 表头列 1 | 表头列 2 | 表头列 3 | | -------- | :------: | -------: | | 表格列 1 | 表格列 2 | 表格列 3 | 分割线 --- *** 列表 - 第一项 - 第二项 * 第一项 * 第二项 1. 第一项 2. 第二项 - [ ] 第一项 - [ ] 第二项 其它 下划线 [超链接](https://baidu.com/) _斜体_ **粗体** **_粗斜体_** ~~删除线~~ > 引用 `代码` ``` 代码块 ``` ~下标~ ^上标^ © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Markdown/Markdown作图.html":{"url":"Markdown/Markdown作图.html","title":"Markdown 作图","keywords":"","body":"Markdown 作图 Mermaid 流程图 graph是声明流程图，T是上，B和D是下，L是左，R是右 graph TD subgraph 子图 A[方形] --实线指向--> B(圆角) B --> C>多边形] end C ---|无指向实线| D{菱形} D --- A A -.虚线指向.-> C B -.-> F D ==粗线指向==> F A ==> F 时序图 sequenceDiagram Github ->> Local: fetch/clone Local -->> Github: push Note left of Github: 远程仓库 Note right of Local: 本地仓库 Note over Github, Local: Git participant A participant B A -> B: Hello, how are you? B --> A: I'm fine, thank you, and you? loop 隔三岔五 A ->> Local: 处理好了没？ alt 好了 Local -->> A: 好了 else Local -->> A: 没呢还 end end 甘特图 gantt dateFormat YYYY-MM-DD title 软件开发 section 设计 需求: done, Need, 2020-01-01, 2020-01-03 原型: active, Prototype, 2020-01-03, 3d UI设计: Draft, after Prototype, 5d section 开发 理解需求: crit, done, 2020-01-01, 24h 设计框架: crit, done, after Prototype, 2d 软件开发: crit, active, 3d section 测试 功能测试: active, funcTest, after des3, 3d 压力测试: after funcTest , 20h 测试报告: 48h 类图 是继承，+是公有，-是私有 classDiagram Animal |>-- Person Animal : +int age Animal: +run() class Person{ +String name +say() } 饼图 pie title Vote 2020 \"Joe Biden\": 51.1 \"Donald Trump\": 47.2 \"Jo Jorgensen\": 1.2 \"Others\": 0.6 标准流程图 ```flow st=>start: 开始框 op=>operation: 处理框 cond=>condition: 判断框 sub1=>subroutine: 子流程 io=>inputoutput: 输入输出框 e=>end: 结束框 st(right)->op->cond cond(true)->io->e cond(false)->sub1(right)->op ``` 标准时序图 ```sequence Title: 标题 Github ->> Local: fetch/clone Local -->> Github: push Note left of Github: 远程仓库 Note right of Local: 本地仓库 Note over Github, Local: Git participant A participant B A -> B: Hello, how are you? B --> A: I'm fine, thank you, and you? ``` © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Markdown/LaTex常用语法.html":{"url":"Markdown/LaTex常用语法.html","title":"LaTex 常用语法","keywords":"","body":"LaTex 常用语法 链接 Detexify官网 常用语法 $行内公式$ {% math %}行间公式{% endmath %} % 乘 除 点乘 开根号 \\times \\div \\cdot \\sqrt[n]{3} % 对数 \\log \\lg \\ln % 与中线对齐的省略号 与底线对齐的省略号 \\underbrace{\\cdots} \\underbrace{\\ldots} % 正负 负正 \\pm \\mp % 大于等于 小于等于 不等于 约等于 恒等于 \\geq \\leq \\neq \\approx \\equiv % 因为 所以 任意 存在 \\because \\therefore \\forall \\exists % 正弦 余弦 正切 余切 正割 余割 直角 角 度 \\sin \\cos \\tan \\cot \\sec \\csc \\bot \\angle ^\\circ % α β γ Δ ε θ λ φ π σ \\alpha \\beta \\gamma \\Delta \\epsilon \\theta \\lambda \\phi \\pi \\sigma % 累加 分数 \\sum_{i=1}^n \\frac{1}{2} % 极限 积分 \\lim_{n \\to +\\infty} \\int_0^1 % 向量 \\vec{x} % 空集 交集 并集 属于 不属于 真包含 包含 被包含 \\emptyset \\bigcap \\bigcup \\in \\notin \\subset \\subseteq \\supseteq % 行标 左括号 右括号 \\tag{} \\left( \\right) % 标注 \\text{文字描述} % 矩阵 \\begin{matrix} \\end{matrix} © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/":{"url":"前端/","title":"前端","keywords":"","body":"前端 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/HTML5+CSS3/":{"url":"前端/HTML5+CSS3/","title":"HTML5+CSS3","keywords":"","body":"响应式网页设计 链接 谷歌字体中文网 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/HTML5+CSS3/HTML5基础.html":{"url":"前端/HTML5+CSS3/HTML5基础.html","title":"HTML5 基础","keywords":"","body":"HTML5 基础 HTML(HyperText Markup Language)，超文本标记语言。是一种用于描述网页结构的标记语言。它使用特定的标签来组织网页结构。其超文本的部分源自于网络早期的使用情况，那时网页通常是静态文档，其中包含对其他文档的引用，而这些引用正是使用超文本链接进行导航跳转的。 随着网页和网络应用越来越复杂，W3C万维网联盟(World Wide Web Consortium)更新了HTML规范，以确保网页能够在任何浏览器上都可以正常显示。 HTML的最新版本是HTML5。 常用标签 大多数HTML元素都有一个开头标签和一个结尾标签。开头标签看起来像这样：，结尾标签是这样的：。开头标签和结尾标签的唯一区别是结尾标签有个正斜杠。 标签支持嵌套。 文档标题 主标题 副标题 三级标题 四级标题 五级标题 六级标题 段落 行内元素 居中 倾斜 加粗 强调 严正强调 删除 这个也是删除 下划线 下标 上标 变大 变小 meta标签是元数据 [info] For Info 屏幕阅读器阅读摘要的做法是提取标题，因此要语义化文档，标题标签仅作标题使用，其余标签如要调整字号字重则使用样式实现。 HTML5新增了多个更加语义化的标签，有助于代码阅读及搜索引擎优化(SEO)。 导航 2020/02/02 章节 脚注 媒体 图像 图像标签为单标签。 图表名 src属性指向图片链接 alt属性的文本用于屏幕阅读器，或在图片加载失败的情况下显示 [info] For Info 无障碍设计要求alt属性必须有，如已有文字描述，则alt属性可置空。 音频 source标签用于加载不同格式的资源 type属性取值有：video/ogg、video/mp4、video/webm、audio/ogg、audio/mpeg controls属性表示显示控件 视频 autoplay属性为自动播放 muted属性为静音播放 loop属性为循环播放 poster属性为视频封面 超链接 死链 href属性指向跳转目标，可以指向文档内的标签id，也可以指向网址 target属性表示跳转操作是在新标签页(_blank)还是自身跳转(_self) [info] For Info 超链接应带有文字描述供屏幕阅读器使用。 列表 无序列表 有序列表 自定义名词 自定义描述 表单 表单域标题 开发者 用户 吃 喝 China Foreign 文本框 提交 action属性指向提交表单数据的服务器地址 method属性表明请求方法 输入框也是单标签。 placeholder属性是占位文本 required属性表明该项为必填项 单选框和复选框会自动与周围标签相关联，所以通常和label标签同用 for属性指向所关联的选项id name属性表明相关选项集合归属 value属性表示表单数据传递值 checked属性表示默认勾选项 accesskey属性用于快捷键聚焦 tabindex属性表示可被键盘按顺序聚焦 表格 表格标题 列一表头 列二表头 列一 列二 列一 列二 [info] For Info Lorem ipsum：乱数假文，仅用于占位，由无实际含义的拉丁文构成，用于测试文章在不同字型或版型下的排版效果。 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/HTML5+CSS3/CSS3基础.html":{"url":"前端/HTML5+CSS3/CSS3基础.html","title":"CSS3 基础","keywords":"","body":"CSS3 基础 CSS(Cascading Style Sheets)，层叠样式表。用于编排网页外观及元素布局。层叠表现在后来者居上，元素会采用溯源离它最近的那个样式。 推荐使用外联式，页面结构与样式相分离。 CSS严格区分大小写 花括号确定样式范围，分号表示语句作结，不可或缺 子元素会继承父元素样式 [info] For Info display: none和visibility: hidden会对所有用户，包括屏幕阅读器隐藏。但display: none不占据空间，而visibility: hidden隐藏依旧占用空间。 如果元素宽高均为 0，则屏幕阅读器也将忽略元素。 选择器 CSS的原理是通过选择器锁定DOM(Document Object Model，文档对象模型)上的元素，改变元素属性，从而施加样式。 /* 伪类选择器 */ :root { /* 变量 */ --val: 200px; } /* 伪元素选择器 */ div::before { content: ''; } /* 标签选择器 */ body { height: var(--val, 100px); } /* 类选择器 */ .container { } /* id选择器 */ #app { } /* 属性选择器 */ input[type='radio'] { } 变量引用可设置默认值 类选择器可复用，class属性可重名 id选择器不可复用，id属性要唯一 伪元素选择器用来制作形状时，通常会将其内容置空 宽高 div { /* 高度 */ height: 100px; /* 宽度 */ width: 100px; /* 最小高度 */ min-height: 50px; /* 最小宽度 */ min-width: 50px; } 尺寸单位有： px：pixels像素，绝对尺寸 rpx：responsive pixels，小程序用的宽度自适应尺寸 vh：视口高度比，相对于视口尺寸 vw：视口宽度比 vmin: 视口最小尺寸 vmax：视口最大尺寸 em：相对父元素对象尺寸 rem：相对根元素对象尺寸 百分比：相对于父容器 文本 p { /* 文本超出标识 */ text-overflow: ellipsis; /* 超出部分处理 */ overflow: hidden; /* 文本换行 */ white-space: nowrap; /* 词间距 */ word-spacing: 4px; /* 字母间距 */ letter-spacing: 1px; /* 换行 */ word-break: normal; word-wrap: normal; /* 垂直对齐 */ vertical-align: bottom; /* 水平对齐 */ text-align: justify; /* 首行缩进 */ text-indent: 40px; /* 齐行 */ text-justify: distribute; /* 字体阴影 */ text-shadow: 2px 2px 5px #000; /* 装饰线 */ text-decoration: lightgreen underline wavy; /* 大小写转换 */ text-transform: lowercase; } text-overflow属性要配合white-space属性和overflow属性使用 vertical-align只对display: inline或display: table-cell的元素有效 text-shadow属性值：水平距离 垂直距离 模糊距离 颜色 text-decoration属性值：颜色 位置 样式 text-decoration属性取值有underline(下划线)、line-through(删除线)等 text-align属性取值有：justify(两端对齐)、center(文本居中)、left(文本居左)、right(文本居右) text-transform属性取值有：lowercase(全小写)、uppercase(全大写)、capitalize(首字母大写)、initial(默认值)、inherit(继承)和none 字体 h1 { /* 字体颜色 */ color: hsla(60, 100%, 50%, 100%) !important; /* 字体 */ font-family: sans-serif; /* 字号 */ font-size: 16px; /* 字重 */ font-weight: bold; /* 字体样式 */ font-style: italic; /* 小型大写字母 */ font-variant: small-caps; /* 行高 */ line-height: 1.5; } !important表示绝对优先 通用字体族名有：monospace(等宽字体，代码首选)、serif(衬线字体，打印首选)、sans-serif(无衬线字体，页面首选)、fantasy和cursive(这两种花里胡哨，纯粹为了好看) 链接 a { /* 鼠标样式 */ cursor: pointer; } /* 链接未被点击状态 */ a:link { /* 英文单词 */ color: red; } /* 链接已被点击状态 */ a:visited { /* 16 进制 */ color: #f00; } /* 鼠标扫过链接状态 */ a:hover { /* rgba值 */ color: rgba(255, 0, 0, 1); } /* 点击链接状态 */ a:active { /* hsla值 */ color: hsla(0, 100%, 50%, 1); } 链接样式书写顺序：link、visited、hover、active，不能颠倒，否则不生效 边框 div { /* 外边距 */ margin: 20px; /* 外边框宽度，不占用盒子模型 */ outline-width: 2px; /* 外边框颜色 */ outline-color: black; /* 外边框样式 */ outline-style: dashed; /* 外边框偏移量 */ outline-offset: 10px; /* 内边距 */ padding: 50px; /* 边框宽度 */ border-width: 10px 2px 3px 4px; /* 边框样式 */ border-style: dotted; /* 边框颜色 */ border-color: blue red gray; /* 圆角半径 */ border-radius: 10px 20%; /* 盒子阴影 */ box-shadow: 5px 5px 5px cyan; /* 边框图片 */ -webkit-border-image: url('https://www.baidu.com/img/fddong_e2dd633ee46695630e60156c91cda80a.gif') 0% 1% 0% round; } margin控制边框与其它元素之间的距离 padding控制边框与内部元素之间的距离 样式顺序：上右下左，顺时针 box-shadow属性值：水平偏移量 垂直偏移量 模糊半径(可选) 扩散半径(可选) 颜色 边框图片属性值：图片地址 向内偏移值 边框宽度 超出边框量 图像边框处理样式 定位 .container { /* 位置类型 */ position: relative; } .item { position: absolute; /* 展现形式 */ display: block; /* 坐标偏移量 */ left: 147px; top: 47px; /* 堆叠次序 */ z-index: -1; } div { /* 浮动 */ float: right; } #photo { /* 块元素水平居中 */ margin: 0 auto; overflow: hidden; /* 是否显示 */ visibility: visible; /* 清除周围浮动 */ clear: right; /* 剪裁 */ clip: rect(0px, 100px, 200px, 0px); } position属性取值有： relative：相对原位置，不会脱离文档流 absolute：相对父容器锁定，脱离文档流。常用有子绝父相布局 fixed：相对浏览器窗口锁定，脱离文档流，不随页面滚动而移动 float属性脱离文档流 z-index属性取值越大越靠近用户 背景 div { /* 背景颜色 */ background-color: repeating-linear-gradient( 90deg, lightsalmon 40px, #cff 20px, #fcc 10px ); /* 透明度 */ opacity: 0.8; /* 背景剪裁 */ background-clip: content-box; /* 背景图片 */ background-image: url('https://www.baidu.com/img/flexible/logo/pc/result.png'); /* 背景图片剪裁 */ background-origin: border-box; /* 背景尺寸 */ background-size: 120px 80px; /* 背景重复 */ background-repeat: repeat-y; /* 背景左上角坐标 */ background-position: 250px 50px; /* 背景滚动 */ background-attachment: local; /* 超出部分处理 */ overflow-y: scroll; } url指向图片链接 颜色 repeating-linear-gradient属性值表示重复线性渐变，参数有：角度，渐变色 渐变色宽度 linear-gradient属性值表示线性渐变，参数有：角度，渐变色顺序 rgba即红 绿 蓝 透明度(0 为透明，1 为不透明) hsla即色相(红黄绿青蓝洋，以 60 为递进，0-360) 饱和度(灰度含量，0-100%) 亮度(黑白含量，0-100%) 透明度 [info] For Info 网页设计通常以一种颜色作为主色，互补色用于强调个别内容。普通文本的相对亮度对比值至少是 4.5: 1。 色盲用户是对某一波长的光的敏感度降低到完全看不到的程度，因此在传达重要信息时要避免使用相似色组合。 常见颜色英文名 十六进制值 RGB值 HSL值 Red #F00 rgb(255, 0, 0) hsl(0, 100%, 50%) Orange #FFA500 Yellow #FF0 rgb(255, 255, 0) hsl(60, 100%, 50%) Green #0F0 rgb(0, 255, 0) hsl(120, 100%, 50%) Cyan #0FF rgb(0, 255, 255) hsl(180, 100%, 50%) Blue #00F rgb(0, 0, 255) hsl(240, 100%, 50%) Magenta或Fuchsia #F0F rgb(255, 0, 255) hsl(300, 100%, 50%) DodgerBlue #1E90FF Orchid rgb(218, 112, 214) Sienna rgb(160, 82, 45) 变换 div { /* 图形变换 */ transform: rotate(30deg); } transform属性取值有： scale：放缩 skewX：水平变形 skewY：垂直变形 rotate：旋转 动画 /* 动画关键帧 */ @keyframes change { from, to { opacity: 0; } } div { /* 动画时长 */ animation-duration: 1s; /* 动画名 */ animation-name: change; /* 动画循环次数 */ animation-iteration-count: infinite; /* 动画终止状态 */ animation-fill-mode: forwards; /* 动画时延 */ animation-delay: 1s; /* 动画播放状态 */ animation-play-state: running; /* 动画时间曲线 */ animation-timing-function: cubic-bezier(0.25, 0.25, 0.75, 0.75); } animation-timing-function属性取值有： ease：中间加速，头尾慢 ease-in：开始慢，后面加速 ease-out：开始加速，后面慢 linear：线性 cubic-bezier：贝塞尔曲线，参数为x1, y1, x2, y2 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/HTML5+CSS3/响应式设计.html":{"url":"前端/HTML5+CSS3/响应式设计.html","title":"响应式设计","keywords":"","body":"响应式设计 如今市面上有各类设备，屏幕尺寸不一，响应式网页设计是一种设计网页内容的方法，用于对症下药，响应不同设备的尺寸。 /* 图片自适应 */ img { /* 确保不会超出容器宽度 */ max-width: 100%; /* 保持宽高比 */ height: auto; } [info] For Info 有些没考虑到高分辨率显示器的图像在Retina显示器中显示可能出现像素化，这是因为像素密度(PPI每尺寸像素或DPI每英寸点数)的不同。 常用解决办法即将图片宽高定义为原始文件的一半大小。 媒体查询 根据不同设备条件，加载不同样式。 @media (min-width: 768px) { } @media (min-width: 992px) { } @media (min-width: 1200px) { } @media (max-width: 767px) { } @media (min-width: 768px) and (max-width: 991px) { } @media (min-width: 992px) and (max-width: 1199px) { } @media (min-width: 1200px) { } © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/HTML5+CSS3/弹性盒子模型.html":{"url":"前端/HTML5+CSS3/弹性盒子模型.html","title":"弹性盒子模型","keywords":"","body":"弹性盒子模型 父容器 .container { /* 弹性盒子模型 */ display: flex; /* 主轴方向 */ flex-direction: row-reverse; /* 折行 */ flex-wrap: nowrap; /* 主轴排列 */ justify-content: space-between; /* 交叉轴排列 */ align-items: center; } flex-wrap属性取值有： nowrap：不折行 wrap：折行 wrap-reverse：逆向折行 justify-content属性取值有： flex-start：对齐到起始位置 flex-end：对齐到末端 space-between：子项间等距，首尾子项贴边 space-around：子项间和首尾子项到边等距 align-items属性取值有： flex-start：对齐到起始位置 flex-end：对齐到末端 center：居中 stretch：拉伸 baseline：基线对齐 子项 .item { /* 空间剩余时的膨胀比 */ flex-grow: 2; /* 空间不足时的缩放比 */ flex-shrink: 3; /* 子项初始大小 */ flex-basis: 100px; /* 显示顺序 */ order: 1; /* 可覆写align-items */ align-self: stretch; } flex属性可连写：flex-grow flex-shrink flex-basis order属性越小越靠前 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/HTML5+CSS3/网格布局.html":{"url":"前端/HTML5+CSS3/网格布局.html","title":"网格布局","keywords":"","body":"网格布局 Grid布局是将网页变成有行列的网格。 父容器 .container { /* 网格布局 */ display: grid; /* 网格列宽 */ grid-template-columns: [c1] 1fr [c2] 2fr [c3]; /* 网格行宽 */ grid-template-rows: repeat(auto-fill, minmax(20%, 1fr)); /* 网格区域命名 */ grid-template-areas: '1 .' '5 .'; /* 列间距 */ grid-column-gap: 2px; /* 行间距 */ grid-row-gap: 5px; /* 排列顺序 */ grid-auto-flow: row dense; /* 子项区域内水平对齐 */ justify-items: center; /* 子项区域内垂直对齐 */ align-items: center; } grid-template-columns和grid-template-rows属性中，fr是片段单位，中括号里是网格线命名。还可用repeat函数和minmax函数 auto-fill会自动添加空行，auto-fit会自适应子项 grid-template-areas属性可用.来指名空网格 grid-gap属性可连写：grid-column-gap grid-row-gap 子项 .item1 { /* 占据行 */ grid-columns: 1/2; /* 占据列 */ grid-rows: 1/2; /* 区域内水平对齐 */ justify-self: start; /* 区域内垂直对齐 */ align-self: end; } .item2 { /* 跨越网格 */ grid-row-start: span 2; } .item3 { /* 指名区域 */ grid-area: 1/2/1/4; } justify-self属性取值有： start：居左 center：居中 end：居右 grid-area属性可用区域名或网格线(起始水平线 起始垂直线 终止水平线 终止网格线) place-self属性可连写justify-self align-self © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/HTML5+CSS3/多列布局.html":{"url":"前端/HTML5+CSS3/多列布局.html","title":"多列布局","keywords":"","body":"多列布局 父容器 .container { /* 分列 */ column-count: 7; /* 列宽 */ column-width: 80px; /* 列距 */ column-gap: 10px; /* 分割线 */ column-rule: 2px outset #12addc; } column-rule属性参数：宽度 样式 颜色 子项 .item { /* 横跨列 */ column-span: all; } © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/JavaScript/":{"url":"前端/JavaScript/","title":"JavaScript","keywords":"","body":"JavaScript © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/JavaScript/JavaScript基础.html":{"url":"前端/JavaScript/JavaScript基础.html","title":"JavaScript 基础","keywords":"","body":"JavaScript 基础 变量与类型 // 单行注释 /* 多行注释 */ // 全局变量声明并赋值 var name = 4; // 控制台清屏 console.clear(); // 类型 console.log(typeof undefined); // undefined，未定义 console.log(typeof true); // boolean console.log(typeof ''); // string console.log(typeof Symbol()); // symbol console.log(typeof 1n); // bigint console.log(typeof 1); // number console.log(typeof {}); // object console.log(typeof null); // object，但null是JS的类型之一，代表空值 变量标识符可以由字母、数字、_和$组成，但不能含有空格且数字不能打头。严格区分大小写 var会变量提升，可重复声明，但后来者居上。var定义的变量会覆盖掉顶层对象的内置属性，浏览器的顶层对象是windows，Node环境的顶层对象是global null的原型对象是undefined [info] For Info 实数存储为浮点数有时会有四舍五入的精度错误，这是因为计算机的本质是用二进制进行存储所导致的。 运算符与转义字符 运算符 列举 算术运算符 +、-、*、/、% 自增自减运算符 ++、-- 赋值运算符 =、+=、-=、*=、/=、%= 关系运算符 ==、===、>、、>=、、!=、!== 逻辑运算符 ` 、&&、!` +也可用于字符串拼接 %：求余运算符，与模数相似，但无法对负数使用 ==和!=会将变量转化为同类型进行比较 转义字符 含义 \\' ' \\\" \" \\\\ \\ \\n 换行 \\r 回车 \\t Tab位 字符串 var str = ''; console.log(str.length); // 字符串长度 console.log(str[0]); // 字符串索引 字符串的内容不可变 函数与作用域 // 函数声明 function queueAdd(arr, item) { // 局部变量 var first = arr.shift(); arr.push(item); // 返回值 return first; } var sum = func(1, 2); // 函数调用 花括号定义局部作用域 局部变量作用域高于全局，故同名覆写 无定义返回值返回undefined 递归函数必须要有收敛条件，递归栈FILO 流程控制 流程控制可嵌套。 // 三目运算符 1 === 0 ? console.log(true) : console.log(false); // if判断 if (1 === 0) { console.log('1 === 0'); } else if (1 0'); } // switch判断 switch (1 === 0) { case true: console.log(true); break; // 缺省语句 default: console.log(false); } // for循环 var arr = []; for (var i = 0; i 数值 console.log(Math.random()); // 返回[0, 1)之间的随机数 console.log(Math.floor(3.14)); // 四舍五入 console.log(parseInt('3.14', 2)); // 字符串转数值 NaN：非数 parseInt函数的参数是：字符串 进制 异常处理 try { } catch { } finally { } 数组 var arr = [ [1, 2], [3, 4], ]; // 多维数组 arr[0][0] = 5; // 数组索引，数组值可变 arr.indexOf([]); // 查询 arr.push([5, 6]); // 添加到尾部 arr.pop(); // 删除并返回数组末尾元素 arr.unshift([0, 1]); // 添加至首部 arr.shift(); // 删除并返回数组首部元素 let newArr1 = arr.splice(1, 2, 50); // 删增元素并返回新数组 let newArr2 = arr.slice(1, 2); // 切片 indexOf方法不存在返回-1 splice参数：删除起始索引 删除元素数量 在原位上新增的元素 slice参数：起始索引 终止索引 对象 键值对结构，键为字符串类型，值为任意类型。可嵌套。 var obj = { one: 1, two: 2, }; // 访问属性并增改 obj.one = '1'; obj['two'] = '2'; obj['list'] = ['a', 0]; delete obj.one; // 删除属性 // 判断属性是否存在 obj.hasOwnProperty('one'); 'two' in obj; // 遍历 for (let i in obj) { } // 键值数组 console.log(Object.keys(obj)); © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/JavaScript/ES6.html":{"url":"前端/JavaScript/ES6.html","title":"ES6","keywords":"","body":"ES6 ECMAScript规范，JavaScript和TypeScript是实践，TypeScript是JavaScript的超集，优先支持ES新特性。 并非所有的浏览器都支持ES6及其以上的新特性。如果在项目中使用新特性，需用编译器将代码转为ES5。 变量声明 // 严格模式 'use strict'; let value = 10; // 常量声明 const VALUE = 100; let声明前调用会形成临时死区(TDZ) const也会形成死区，但必须立即赋值 [info] For Info 变量标识符以camelCase为命名规范，而常量标识符应为全大写，单词之间用_隔开 let obj = { one: 1, }; Object.freeze(obj); // 禁止改动 函数 let fu1 = function () {}; // 箭头函数 let fn2 = (...args) => args[0]; // IIFE (function () {})(); let person = { name: '', // ES6中可以省略function关键字 sayHi() {}, }; let arr = [1, 2, 3, 4]; // REST运算符 Math.max(...arr); 箭头函数如果只有一个参数，则参数括号可省略 箭头函数如果只有一条执行语句，则函数体括号也可省略 ES6中函数参数可设置默认值 IIFE：Immediately Invoked Function Expression，立即调用函数表达式 析构 let obj = { greeing: 'Halo', name: 'Amy', score: [1, 2, 3], }; // 对象解构 let { greeting, name: userName, score, gender = 'female' } = obj; // 数组解构 let [f, s, l] = score; // 解构互换 let [f, s] = [s, f]; 模板字符串 let age = 12; console.log(`I'm ${age} years old.`); 类 ES6中的类不是完整的基于类的面向对象编程范式的实现，其本质还是原型继承。 class Animal { // 私有属性 #age; // 构造函数 constructor(name: string, age: int) { this._name = name; this.#age = age; } // Getter函数 get name() { return this._name; } // Setter函数 set name(newName) { this._name = newName; } } let a = new Animal('Bingo', 18); a.name = ''; console.log(a.name); 类名使用UpperCamelCase规范 构造函数在new时调用 私有变量标识符以_起头 Getter函数用于外部访问私有变量 Setter函数用于外部设置私有变量 模块 import React, { PureComponent } from 'react'; class App extends PureComponent {} export {}; // 默认导出 export default App; 每个模块只能有一个export default Promise Promise是异步通信编程的一种解决方案，避免回调地狱。有pending、Fulfilled和Rejected三种状态。 const promise = new Promise((resolve, reject) => { if (false) { resolve('Fulfilled'); } else { reject('Rejected'); } }); // 链式调用 promise.then((value) => {}).catch((err) => {}); Promise.all([]); // 异步Promise排序输出，但要全部完成才会输出，而且一个失败全部失败 Promise.race([]); // 只输出第一个改变状态的示例 Promise.resolve(); // 只输出一个成功实例 Promise.reject(); // 只输出一个失败实例 链式调用返回的是Promise对象 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/JavaScript/正则表达式.html":{"url":"前端/JavaScript/正则表达式.html","title":"正则表达式","keywords":"","body":"正则表达式 正则表达式用于字符串搜索匹配。 let str = 'HaloWorld'; let testRegex1 = /W/; // 单字匹配 testRegex1.test(str); let testRegex2 = /W[059a-u]/; // 多候选匹配 testRegex2.test(str); let testRegex3 = /(H|W)/; // 或 testRegex3.test(str); let testRegex4 = /[^H]/; // 非 testRegex4.test(str); let testRegex5 = /W/i; // 忽略大小写 testRegex5.test(str); let testRegex6 = /W/g; // 全匹配 testRegex6.test(str); let testRegex7 = /./; // 通配符 testRegex7.test(str); let testRegex8 = /a+/; // 一到多次 testRegex8.test(str); let testRegex9 = /a*/; // 零到多次 testRegex9.test(str); let testRegex10 = /a?/; // 懒惰匹配，零到一次 testRegex10.test(str); let testRegex11 = /\\w+/; // 匹配大小写字母、数字及_ testRegex11.test(str); let testRegex12 = /\\W+/; // 匹配非大小写字母、数字及_的字符 testRegex12.test(str); let testRegex13 = /\\d+/; // 匹配数字 testRegex13.test(str); let testRegex14 = /\\D+/; // 匹配非数字 testRegex14.test(str); let testRegex15 = /\\s+/; // 匹配空白、Tab位、回车、新行和换行字符 testRegex15.test(str); let testRegex16 = /\\S+/; // 匹配非空白、Tab位、回车、新行和换行字符 testRegex16.test(str); let testRegex17 = /a{1,}+/; // 次数 testRegex17.test(str); let testRegex18 = /(\\w)\\1/; // 指定捕获组 testRegex18.test(str); let testRegex19 = /H(?=a)/; // Lookaheads匹配，后带有 testRegex19.test(str); let testRegex20 = /H(!=a)/; // Lookaheads匹配，后带无 testRegex20.test(str); let testRegex21 = /^H/; // 开头 testRegex21.test(str); let testRegex22 = /H$/; // 结尾 testRegex22.test(str); let testRegex23 = /W/; str.match(testRegex23); // 反查 str.replace(testRegex23, 'M'); // 替换 正则表达式默认贪婪匹配 捕获组即圆括号限定，在replace中使用$指定 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/JavaScript/面向对象编程.html":{"url":"前端/JavaScript/面向对象编程.html","title":"面向对象编程","keywords":"","body":"面向对象编程 let obj = { name: '', sayName: function () { // 指向对象引用 return this.name; }, }; // 构造函数 function Bird(name) { this.name = name; } let bird = new Bird(); // 实例化 console.log(bird instanceof Bird); // 验证实例从属 bird.hasOwnProperty('name'); // 自身属性查询 Bird.prototype.isPrototypeOf(bird); // 原型对象判断 // 原型链 Bird.prototype = { constructor: Bird, numLeg: 2, }; bird.constructor === Bird; // 对象溯源 function Animal() {} Animal.prototype.eat = function () { console.log('eat'); }; Bird.prototype = Object.create(Animal.prototype); // 继承 Bird.prototype.constructor = Bird; // 消除副作用 // 重载 Bird.prototype.eat = function () { console.log(this.name + 'eat'); }; 构造函数首字母大写 原型链上的属性所有实例共享 原型链添加属性有副作用，会将构造函数覆盖 Mixins 为不相关的对象提供相同的方法。 let motionModule = (function () { return { flyMixin: function (obj) { obj.fly = function () { console.log('Flying, wooosh!'); }; }, }; })(); let bird = { name: 'bird', }; let plane = { name: 'plane', }; motionModule.flyMixin(bird); motionModule.flyMixin(plane); 闭包 function Bird() { let egg = 10; // 私有变量 this.getEggCount = function () { return egg; }; } 公共方法与私有变量在相同的Context中声明，公共方法始终能够访问创建它的上下文，形成闭包 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/JavaScript/函数式编程.html":{"url":"前端/JavaScript/函数式编程.html","title":"函数式编程","keywords":"","body":"函数式编程 函数式编程不依赖程序状态或全局变量，只依靠传递进来的参数进行计算，在函数以外副作用最小 理想状态下，应为相同输入必然得到相同输出的纯函数，而无会改变事物结果的副作用 回调：将函数传入另一个函数，由其决定函数调用 高阶函数：将函数作为参数或作为返回值的函数 lambda：传入或从高阶函数中返回出来的函数 如果会产生副作用，必须始终显式声明依赖项 const arr = [ { name: 'zhangsan', age: 17 }, { name: 'lisi', age: 18 }, { name: 'wangwu', age: 19 }, { name: 'zhaoliu', age: 20 }, ]; arr.push(['a', 'b', 'c']); // 添加元素 const sum = arr.reduce((sumVal, a) => { sumVal + a.age; }, 0); const ages = arr.map((a) => a.age); // map迭代数组项 const person = arr.filter((a) => a.name.length reduce方法需要加入初值 push方法不是函数式编程，它使得原数组变异 map、filter、splice和concat方法都不改变原始数组，返回的是一个新数组 slice方法也不改变原始数组，返回元素副本 sort方法有副作用，可以使用空数组来规避副作用 every方法全满足返回true some方法有满足即返回true © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/Vue/":{"url":"前端/Vue/","title":"Vue","keywords":"","body":"Vue3 链接 Node.js官网 NPM库 包管理工具(三选一即可) ~/$ npm i -g cnpm # 全局安装CNPM ~/$ npm i -g yarn # 全局安装Yarn ~/$ npm config set registry https://registry.npm.taobao.org # NPM使用淘宝源 ~/$ yarn config set registry https://registry.npm.taobao.org # Yarn使用淘宝源 ~/$ npm i # NPM初始化项目 ~/$ cnpm i # CNPM初始化项目 ~/$ yarn add # Yarn初始化项目 ~/$ npm i -g create-vite-app # 安装Vite脚手架 ~/$ create-vite-app Project # 新建Vue3项目 CNPM是用了淘宝镜像的NPM，国内访问速度更快 Yarn是Facebook推出的类NPM包管理工具 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/Vue/Vue项目结构.html":{"url":"前端/Vue/Vue项目结构.html","title":"Vue 项目结构","keywords":"","body":"Vue3 项目结构 ~/$ tree . ├── index.html: HTML模板 ├── node_modules: NPM包 ├── package.json: 项目描述文件 ├── package-lock.json: 依赖包版本锁定文件 ├── public: 公用资源 └── src: 项目文件 ├── App.vue: 根组件 ├── assets: 资源目录 ├── components: 组件 ├── index.css: 全局样式 └── main.js: 项目入口文件 添加 TS 支持 更改入口文件后缀名 更改HTML模板 添加shims-vue.d.ts类型声明文件 declare module '*.vue' { import type { DefineComponent } from 'vue'; const component: DefineComponent; export default component; } [info] For Info 红线提示vue/no-multiple-template-root是Vue2的遗留。 Vue的虚拟DOM将VNode设计成了单一root节点的树状结构，render时只会识别第一个根节点。 Vue3会自动将多节点使用新组件Fragment包裹，这样可以减少代码层级，降低内存占用。 main.ts import { createApp } from 'vue'; import App from './App.vue'; // 导入根组件 createApp(App).mount('#app'); // 创建应用实例，并挂载到HTML模板中id为app的标签下 App.vue // HTML模板 HTML // TS脚本 import HelloWorld from './components/HelloWorld.vue'; // 导入子组件 // 模块默认导出 export default { name: 'App', // 组件名 // 注册子组件 components: { HelloWorld, }, }; // CSS样式 h1 { color: red; } © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/Vue/setup与ref.html":{"url":"前端/Vue/setup与ref.html","title":"setup 与 ref","keywords":"","body":"setup 与 ref 所有Composition API都放setup中，但setup在beforeCreate之前执行且仅一次，则无法使用组件实例对象this。 Vue3 // 插值语法 {{ num }} +1 import { Ref, ref } from 'vue'; export default { // 复合API入口 setup() { const num: Ref = ref(0); // 基本类型的响应式对象 function add(): void { num.value++; // 操作响应式对象的数据 } return { num, add }; }, }; @：v-on:绑定事件 ref通过对数据的value属性添加setter和getter方法劫持，传入对象则会经过reactive处理为Proxy对象 template中要使用setup返回出来的属性需要用插值语法 响应式：数据变化，则页面随之更新 setup中合并了Vue2中的data和methods setup返回的数据要在tempalte中使用，所以不能async，否则返回的是一个Promise对象 setup 参数 props：父级组件传下来的数据，需要在子组件的props中进行接收 context.attrs：在props中无声明但接收了的属性对象 context.emit：分发事件方法，子传父 context.slots：插槽 Vue2 {{ num }} +1 export default { // 属性 data() { return { num: 0, }; }, // 方法 methods: { add() { this.num++; }, }, }; Vue2 的响应式实现 Object.defineProperty(data, 'num' { // 对已有属性进行读写 get (){}, set (){} }); 对新增和删除无效 响应式数组是通过重写来进行更新的，后来采用$set进行部分操作 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/Vue/reactive与TypeScript类型.html":{"url":"前端/Vue/reactive与TypeScript类型.html","title":"reactive 与 TypeScript 类型","keywords":"","body":"reactive 与 TypeScript 类型 基础类型响应式用ref，复合类型响应式用reactive。 {{ name }} {{ age }} {{ nickName }} Click import { reactive, toRefs } from 'vue'; // 接口 interface Person { readonly name: string; // 只读 age?: number; // 可选 nickName: string; } interface Func { (): void; } export default { setup() { const person: Person = { name: '张三', age: 18, nickName: '狗蛋', }; const personProxy: Person = reactive(person); // 复合类型的响应式对象 // 箭头函数 const sayHi: Func = (): void => { console.log( `My name is ${personProxy.name}, I'm ${personProxy.age++}.` ); delete personProxy.nickName; // 删除属性 }; return { ...toRefs(personProxy), // 析构reactive为ref sayHi, }; }, }; 接口用于约束变量 操作响应式对象的数据，并使得页面更新渲染，则需要使用代理器对象进行操作 Vue3 的响应式实现 new Proxy(data, { get(target, props) { return Reflect.get(target, props); }, set(target, props, val) { return Reflect.set(target, props, val); }, deleteProperty(target, props) { return Reflect.deleteProperty(target, props, val); }, }); reactive使用ES6的Proxy实现，接收一个普通对象并返回一个响应式代理器对象，将对象内部所有嵌套属性全部转换成响应式数据 Proxy的handler共有 13 种方法，配合Reflect对象返回目标对象的静态方法 TypeScript 类型 // 数组类型 const arr: Array = [1, 2, 3]; const arr: string[] = ['a', 'b', 'c']; // 枚举类型 enum Gender { Boy, Girl, Other, } const gender: Gender = Gender.Other; 基础类型有string、number、boolean、undefined、null和object 任意类型any，严格任意类型unknown 函数返回空值类型void TS兼容JS，所以支持类型推断 类型断言 // 联合类型 function getLen(x: string | number): void { if ((x).length) { return (x as string).length; } else { return x.toString().length; } } 类型断言可以使用<>或as © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"前端/Vue/computed、watch与watchEffect.html":{"url":"前端/Vue/computed、watch与watchEffect.html","title":"computed、watch 与 watchEffect","keywords":"","body":"computed、watch 与 watchEffect watch: import { Ref, ref, computed, watchEffect, watch } from 'vue'; export default { setup() { let name: string = '张三'; const change = computed({ get() { return name; }, set(val: string) { name = val; }, }); const nameW: Ref = ref(''); watch( () => name, (val: string) => { nameW.value = val; }, { immediate: true, // 默认执行一次 deep: true, // 深度监听 } ); watchEffect(() => { name = nameW.value; }); return { name, nameW }; }, }; v-model：:value和@的结合，绑定并监听数据 watch监听非响应式数据或reactive对象属性时，需要使用回调函数 watchEffect监听会默认immediate © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/":{"url":"Golang/","title":"Golang","keywords":"","body":"Golang 链接 Golang 标准库文档 应用领域 区块链(Blockchain Technology)：分布式账本技术，本质是互联网数据库，去中心化、公开透明 后端服务器 云 DOS 命令 DOS是磁盘操作系统(Disk Operating System) ~/$ dir # 查看当前目录 ~/$ cd .. # 切换目录 ~/$ md newDir # 新建目录make directory ~/$ rd newDir # 删除目录 ~/$ copy demo.txt . # 复制 ~/$ move demo.txt . # 移动 ~/$ del demo.txt # 删除 ~/$ clr # 清屏 ~/$ exit # 退出 进制 进制转换 十进制转二进制：不断除二，然后将余数倒置 二进制转十进制：从低位往高位求$2^n$加和 原码、补码和反码 二进制最高位为符号位，0 正 1 负 正数和 0 的原码、补码和反码都一样 负数的反码=原码除符号位外其余取反 负数的补码=反码+1 计算机运算以补码进行 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang基础/":{"url":"Golang/Golang基础/","title":"Golang 基础","keywords":"","body":"Golang 基础 链接 Go 语言中文网下载页面 安装 ~/$ wget https://golang.org/dl/go1.15.linux-amd64.tar.gz # 下载 ~/$ tar -C /usr/local -xzf go1.15.linux-amd64.tar.gz # 解压 ~/$ sudo nano /etc/profile # 系统环境设置 ~/$ sudo source /etc/profile # 更新系统变量 系统变量配置 export GOROOT=/usr/local/go export GOPATH=Golang项目存放路径 export GOBIN=$GOPATH/bin export PATH=$PATH:$GOROOT/bin export PATH=$PATH:$GOPATH/bin 常用命令 ~/$ go build main.go -o main # 编译main包 ~/$ go install main.go # 普通包安装在$GOPATH/pkg下，main包安装在$GOPATH/bin下 ~/$ go clean # 移除缓存 ~/$ gofmt -w package # 格式化项目文件夹中的全部源码 ~/$ go get # 远程拉取 ~/$ go test *_test.go # 测试 ~/$ go help # 查看帮助 ~/$ go version # 查看版本号 时间 package main import \"time\" func main() { // 当前时间 /* 年：now.Year() 月：now.Month() 日：now.Day() 时：now.Hour() 分：now.Minute() 秒：now.Second() 时间戳：now.Unix()或now.UnixNano() */ /* 纳秒：time.Nanosecond 微秒：time.Microsecond 毫秒：time.Millisecond 秒：time.Second 分：time.Minute 时：time.Hour */ now := time.Now() // 格式化时间，数字固定 now.Format(\"2006-01-02 15:04:05\") } © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang基础/变量、常量、类型与运算符.html":{"url":"Golang/Golang基础/变量、常量、类型与运算符.html","title":"变量、常量、类型与运算符","keywords":"","body":"变量、常量、类型与运算符 // 标识同级包 // 想让程序运行，必须要有main包 // 除了main包，普通包会生成*.a的包文件 package main // 导入包 import ( \"fmt\" \"strconv\" \"strings\" ) // 类型别名 type boolean bool // 计算机将内存分成不同区域，数据存储其中，通过内存地址可以操作数据 // 变量用来表示数据，减少变量定义，可以降低内存占用 // 显式声明 // 仅声明不赋值，将初始化为零值 var val int // 多变量声明 // 常量赋值 const ( C = 10 // 枚举 // 在第一个iota声明时，iota会被置为0 a = iota b c ) // 主程序入口，main包中有且仅有一个主入口函数，无参无返回值 func main() { // 输入 /* %q：转义 %%：转义% %b：二进制数 %o：八进制数 %d：十进制数 %x或%X：十六进制数 %s：字符串 %c：字符型，照ASCII码转换 %f：浮点数 %p：十六进制地址 %T：值类型 %t：布尔值 */ fmt.Scanf(\"%d\", &val) // 自动推导类型，仅限局部 num := 20 // 数据置换，用多重赋值实现 val, num = num, val // 换行输出 // 类型转换必须显式声明，并且只能发生在相互兼容类型之间，Go语言中不允许隐式转换 fmt.Println(float64(C)) /* 1. 算术运算符：+、-、*、/、%(求余)、++(后自加)、--(后自减) 2. 赋值运算符：=、+=、-=、*=、/=、%=、>=、&=、^=、|= 3. 关系运算符：==、!=、、= 4. 逻辑运算符：!、&&(短路与)、||(短路或) 5. 位运算符：&(按位与)、|(按位或)、^(取反、按位异或，不同取1，相同取0)、&^(如果第二个数某位为1，则修改第一位数对应位为0，然后再按位与)、> 6. 其他运算符：&(取地址符)、*(取值符) */ fmt.Println(^4 == -5) strArr := []string{ \"10\", \"20\", \"30\", } // 返回格式化字符串 fmt.Sprintf(\"%#v\", strArr[0]) // 计数 strings.Count(strArr[0], \"1\") // 包含 strings.Contains(strArr[0], \"a\") // 拼接 strings.Join(strArr, \"+\") // 返回位置值 strings.Index(strArr[0], \"1\") // 重复n次 strings.Repeat(strArr[0], 3) // 替换n次，小于0全部替换 strings.Replace(strArr[0], \"1\", \"0\", -1) // 分隔 strings.Split(strArr[0], \"\") // 去头尾 strings.Trim(strArr[0], \"0\") strings.TrimLeft(strArr[0], \"0\") strings.TrimRight(strArr[0], \"0\") strings.TrimSpace(strArr[0]) // 按空分割 strings.Fields(strArr[0]) // 不区分大小写比较 strings.EqualFold(strArr[0], strArr[1]) // 判断字符串前缀 strings.HasPrefix(strArr[0], \"1\") // 判断字符串尾缀 strings.HasSuffix(strArr[0], \"0\") // 转化为字符串 strconv.FormatBool(false) // f是打印格式以小数形式，保留n位，64是以float64处理 strconv.FormatFloat(1.2, 'f', 3, 64) // 返回对应的二进制字符串 strconv.FormatInt(123, 2) strconv.Itoa(100) string([]byte{97, 99}) // 转化成其它类型 strconv.ParseBool(strArr[0]) strconv.ParseFloat(strArr[0], 64) strconv.Atoi(strArr[0]) slice := make([]byte, 0) // 添加至字节数组 strconv.AppendBool(slice, true) strconv.AppendQuote(slice, \"\") strings.ToLower(\"Go\") } 变量命名规范 以Unicode字母或下划线开头 大小写敏感 不能是有特定含义的字符、保留字或关键字 驼峰命名法 尽量望文生义 数据类型 unsafe.Sizeof方法查看变量所占空间。 bit是最小存储单元，byte是基本存储单元，$1byte=8bit$ E：科学计数法 布尔：bool占 1 字节 整型：int、uint占 1 字节、int8、uint8(byte)占 1 字节、int16、uint16占 2 字节、int32(rune)、uint32占 4 字节、int64、uint64占 8 字节，精确位数$2^n$，unsign为无符号 浮点型：float32占 4 字节、float64占 8 字节，浮点型有符号 字符串：string，字符串不可变 复数类型：complex64(32 位实数+32 位虚数)、complex128(64 位实数+64 位虚数) 指针：uintptr 字符 转义字符 \\n：换行 \\t：Tab位 反引号：原生输出 字符和字符串 字符单引号 字符串隐藏结束符\\0 字符串底层是个字节数组，要改写需转换成字节数组改动后再转回来 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang基础/流程控制.html":{"url":"Golang/Golang基础/流程控制.html","title":"流程控制","keywords":"","body":"流程控制 避免多层嵌套，建议控制在 3 层以内，否则影响性能。 package main import ( \"fmt\" ) var i int func main() { fmt.Scanf(\"%d\", &i) // if结构 if i > 0 { fmt.Printf(\"%d > 0\", i) } else if i 0: fmt.Printf(\"%d > 0\", i) case i © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang基础/函数.html":{"url":"Golang/Golang基础/函数.html","title":"函数","keywords":"","body":"函数 将可重用代码进行封装。 函数的默认值传递，即传参数副本，函数内改动不影响原值。 每个源文件中都可包含一个init函数，将会在main函数执行前被调用。全局变量定义在init函数之前执行。 package main import \"fmt\" func main() { add(1, 2) // 固定参数必须传值 sum(0, 1, 2, 3, 4, 5) fmt.Println(factorial(10)) } // 普通参数列表 func add(a, b int) (int, error) { // 函数嵌套 // 匿名函数 f := func() { fmt.Printf(\"%d+%d=%d\\n\", a, b, a+b) } f() // 多返回值 return a + b, nil } // 不定参数列表只能放在形参最后一位 // 不定参数列表可以视需要传值 func sum(num int, args ...int) int { for i := 0; i 作用域 定义在函数外部的变量就是全局变量，函数内部的即是局部变量。同名局部变量会屏蔽全局变量，所以要尽可能避免重名。 闭包 闭包Closure是一个函数和与其相关的引用环境组合而成的一个实体。 package main import ( \"fmt\" ) func main() { fn := closure() fmt.Println(fn(1)) fmt.Println(fn(1)) fmt.Println(fn(1)) } func closure() func(int) int { n := 0 // 返回出来的函数与它所引用到的变量共同形成闭包 return func(x int) int { n += x return n } } © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang基础/复合类型.html":{"url":"Golang/Golang基础/复合类型.html","title":"复合类型","keywords":"","body":"复合类型 package main import \"fmt\" // 结构体 type Student struct { name string gender string score int } func main() { // 数组是一系列同类型数据集合 // 元素紧密排列，首位元素地址即数组首地址，元素地址间隔根据类型决定 // 数组长度是其属性之一 arr := [5]int{4, 3, 2, 5, 1} for _, v := range bubbleSort(arr) { fmt.Println(v) } // 切片长度不固定 slice := []int{1, 2, 3, 4, 5, 6, 7} // copy是将后者复制到前者，以长度短的为准 // 数组[起点:终点:容量] copy(slice, arr[:5:5]) fmt.Println(slice) // 字典，默认无序 // make只适用于内置数据结构，即map、channel和slice，返回带有非零初值的类型本身。new适用于所有，返回指针 dict := make(map[string]int, 3) dict[\"one\"] = 1 len(dict) delete(dict, \"one\") student := Student{ name: \"Lili\", gender: \"girl\", score: 0, } student.learn() } // 栈中存放变量，堆中存放引用对象 // 指针用来存储任何一个变量的内存地址 // 不要操作没有合法执行的内存 func (s *Student) learn() { if s.score arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] } } } return arr } // 切片删除 func sliceDelete(slice []int, startIndex, endIndex int) []int { // append是将后者往前者增加，本质是对数组的扩容 return append(slice[:startIndex], slice[endIndex:]...) } // 切片插入 func sliceInsert(slice []int, index int, args ...int) []int { return append(append(slice[:index], args...), slice[index:]...) } © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang基础/面向对象.html":{"url":"Golang/Golang基础/面向对象.html","title":"面向对象","keywords":"","body":"面向对象 面向过程强调步骤过程。尽量在程序内减少匿名组合，否则会增加复杂度。 Go语言中没有继承、重载(方法名一致，参数类型或个数不一致)。 封装(encapsulation)，将抽象出来的字段和对字段的从左封装在一起，数据被保护在内部，程序的其他包只有通过被授权的操作，即方法，才可以对字段进行操作。封装可以隐藏实现细节，对数据进行验证以确保安全合理。 package main import ( // JavaScript Object Notation，在网络传输中，程序将对象序列化成JSON字符串，接收方将JSON字符串反序列化成对象。 \"encoding/json\" \"fmt\" ) // 结构体的所有字段在内存中是连续的 type Person struct { Name string `json:\"name\"` // tag可以通过反射机制获取，常用于序列化和反序列化。要序列化，需将字段名暴露 } type Student struct { // Go语言中通过匿名组合嫁接功能 // 匿名组合只有类型没有名称 Person // 如遇同名字段，则有屏蔽现象 learn func(string) } type Mentor struct { *Person } // 接口只有声明，没有实现，由类型去实现 // 接口用于实现多态 type Teacher interface { teach(string) eat() } var ( t Teacher teacher Mentor p Person ) func main() { human := Person{ \"human\", } // 序列化 jsonStr, _ := json.Marshal(&human) fmt.Println(string(jsonStr)) // 反序列化 err := json.Unmarshal(jsonStr, &p) if err != nil { fmt.Println(err) } student := Student{ Person: Person{ Name: \"Lili\", }, learn: demo, } fmt.Println(student.Person.Name) // 指针类型匿名字段需要指向，否则无法使用 // new是分配空间，返回指针类型 teacher.Person = new(Person) teacher.Person.Name = \"Confucius\" // 只要结构体实现对应接口，则根据该结构体创建的对象，可以赋值给对应接口类型 // 接口可以超集转子集 t = &Mentor{} t.teach(\"teach\") } func demo(str string) { fmt.Println(str) } // 方法，有接收者声明 // 方法的类型要用类型别名 func (t *Mentor) teach(str string) { demo(str) } // 同名方法重写 func (t *Mentor) eat() { demo(\"eat nice\") } © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang基础/类型断言.html":{"url":"Golang/Golang基础/类型断言.html","title":"类型断言","keywords":"","body":"类型断言 package main import ( \"fmt\" ) func main() { a := \"afads\" typeAssert(a) } // 空接口可代指任何类型 func typeAssert(data interface{}) { // 类型断言 switch data.(type) { case int: fmt.Println(\"Int\") case string: fmt.Println(\"String\") default: fmt.Println(\"Other Type\") } } © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang基础/异常处理.html":{"url":"Golang/Golang基础/异常处理.html","title":"异常处理","keywords":"","body":"异常处理 package main import ( \"errors\" \"os\" ) func main() { // _是匿名变量 /* 1. 操作模式：os.O_RDONLY(只读)、os.O_WRONLY(只写)、os.O_RDWR(读写)、os.O_APPEND(追加)、os.O_CREATE(不存在时创建)、os.O_TRUNC(打开时截断) 2. 权限：0(无权限)、1(执行)、2(写)、3(写+执行)、4(读)、5(读+执行)、6(读写)、7(全权限) */ file, err := os.OpenFile(\"./demo.txt\", os.O_RDONLY, 6) if err != nil { err := errors.New(\"Err\") // 报告致命错误 panic(err) } // 延迟运行，执行顺序从下至上，因为压栈是个FILO队列 // 为了在函数执行完毕后能及时地释放资源 defer func() { // 拦截错误，防止崩溃 recover() file.Close() }() } © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang基础/文件处理.html":{"url":"Golang/Golang基础/文件处理.html","title":"文件处理","keywords":"","body":"文件处理 package main import ( \"bufio\" \"fmt\" \"io\" \"os\" \"io/ioutil\" ) func main() { filePath := \"demo.txt\" createFile(filePath) file, _ := os.OpenFile(filePath, os.O_WRONLY | os.O_APPEND, 0666) defer file.Close() writer := bufio.NewWriter(file) writer.WriteString(\"Halo\") // writer是带缓存的，调用方法时，其实是先写入缓存，所以需要调用Flush方法，将数据写入到文件中 writer.Flush() data, _ := ioutil.ReadFile(filePath) fmt.Println(data) } func createFile(filePath string) { // 创建文件，返回文件和错误值 // 已经存在的文件不能使用Create f, err := os.Create(filePath) if err != nil { return } // 写入数据，返回写入长度和错误值 WSLength, _ := f.WriteString(\"Halo\") WLength, _ := f.Write([]byte(\"World\")) s, _ := f.Seek(0, os.SEEK_END) WALength, _ := f.WriteAt([]byte(\"!\\n\"), s) fmt.Println(WSLength, WLength, WALength) defer f.Close() } func readFile(filePath string) { f, err := os.Open(filePath) if err != nil { return } defer f.Close() buffer := make([]byte, 2*1024) length, err := f.Read(buffer) if err != nil && err == io.EOF { return } fmt.Println(string(buffer[:length])) } func readLines(filePath string) { f, _ := os.Open(filePath) r := bufio.NewReader(f) for { // 遇到换行结束 buffer, err := r.ReadBytes('\\n') if err != nil && err == io.EOF { break } fmt.Println(string(buffer)) } defer f.Close() } func pathExists(filePath string) (bool, error) { _, err := os.Stat(filePath) if err == nil { return true, nil } if os.IsNotExist(err) { return false, nil } return false, nil } os.Args 和 flag 包 os.Args用于记录命令行参数的字符串数组。flag包用来解析命令行参数。 package main import \"flag\" // 定义变量用于接收命令行参数值 var port int func main() { flag.IntVar(&port, \"port\", 3306, \"端口号\") // 转换 flag.Parse() } © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang基础/反射机制.html":{"url":"Golang/Golang基础/反射机制.html","title":"反射机制","keywords":"","body":"反射机制 什么是反射机制？ 反射(reflect)可以在运行时动态获取变量信息 通过反射，可以修改变量的值，即调用方法 package main import ( \"fmt\" \"reflect\" ) type Person struct { Name string `json:\"name\"` Age int `json:\"age\"` Sexual string `json:\"gender\"` } func main() { p := Person{ Name: \"Lili\", Age: 20, Sexual: \"female\", } rVal := reflect.ValueOf(p) // reflect类型转为interface{} iVal := rVal.Interface() // interface{}转为原类型 v := iVal.(Person) fmt.Println(v) ageVal := reflect.ValueOf(&p.Age) // .Elem用于获取指向变量的指针 ageVal.Elem().SetInt(18) fmt.Println(p) } func jsonTags(v interface{}) { // 获取reflect类型 vType := reflect.TypeOf(v) // 原类型转为reflect类型 val := reflect.ValueOf(v) // reflect.Value.Kind是类型种类 vKind := val.Kind() if vKind != reflect.Struct { return } // 获取字段数 fieldNum := val.NumField() // 获取方法数 methodNum := val.NumMethod() for i := 0; i © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang网络编程/":{"url":"Golang/Golang网络编程/","title":"Golang 网络编程","keywords":"","body":"Golang 网络编程 网络编程分类 TCP socket编程，底层基于TCP/IP协议 B/S开发的HTTP编程，用HTTP协议，底层也是TCP/IP协议实现的 什么是 TCP/IP？ TCP/IP(Transmission Control Protocol/Internet Protocol)，传输控制协议/因特网互联协议，又称网络通讯协议。网络层的IP协议和传输层的TCP协议组成因特网基础。 graph TD subgraph TCP/IP协议群 subgraph 应用协议 HTTP SMTP FTP TELNET SNMP end subgraph 传输协议 TCP UDP end subgraph 路由控制协议 RIP OSPF BGP end subgraph 网际协议 IP ICMP ARP end end OSI 理论模型 解释 应用层 (application) 为应用程序提供服务 表示层 (presention) 数据格式转化、数据加密 会话层(session) 建立、管理和维护会话 传输层(transport) 建立、管理和维护端到端的连接 网络层(ip) IP 选址及路由选择 数据链路层(link) 提供介质访问和链路管理 物理层(physical) 物理层 OSI(Open System Interconnection Reference Model)开放式系统互联通信参考模型。 TCP 协议与 UDP 协议 TCP协议与UDP协议是在两硬件设备上进行通信传输的一种数据语法。 STREAM 流式Socket面向连接，安全，但是效率低；TCP就是以流的形式来传的。 DATAGRAM 数据报式Socket是一种无连接的Socket，不安全(容易丢失、顺序混乱、在接收端要分析重排及要求重发)，但效率高，传输速度要比TCP快。UDP将数据包拆开为若干份，编号后来传输。 ip 地址与端口 ipv4(32 位)，ipv6(128 位)。 TCP/IP中的端口(port)是逻辑端口，一个ip地址上的端口可以由 256\\times256 个之多。一个端口只能由一个程序监听。 0 是保留端口 1-1024 是固定有名端口：22 是SSH远程登录协议、23 是telnet协议、21 是ftp、25 是smtp服务、80 是iis、7是echo服务 1025-65535 是动态端口，可用 ~/$ netstat -anb # 查看监听端口及其pid C/S 通信过程 sequenceDiagram participant Client participant Server Client ->> Server: 发送请求 Server -->> Client: 返回结果 Note left of Client: 接收输入 Note right of Server: 接收数据，处理 Note over Client, Server: 消息协议 发送与接收流程 客户端发送 先创建一个结构体 需要有消息类型、消息内容 对消息进行序列化 先发送消息长度，再发送消息本身，避免丢包 服务器接收流程 接收到客户端发送的长度 根据长度接收消息本身 判断消息长度和消息本身 接收无误，反序列化消息 反序列化消息主体数据 后台处理 返回结果，并发送给客户端 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang网络编程/示例代码.html":{"url":"Golang/Golang网络编程/示例代码.html","title":"示例代码","keywords":"","body":"示例代码 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang专题/":{"url":"Golang/Golang专题/","title":"Golang 专题","keywords":"","body":"Golang 专题 References 《Go语言核心 36 讲》 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang专题/开发环境配置与程序实体.html":{"url":"Golang/Golang专题/开发环境配置与程序实体.html","title":"开发环境配置与程序实体","keywords":"","body":"开发环境配置与程序实体 设置 GOPATH 有什么意义？ 为了集中组织代码，方便相互引用。 环境变量GOPATH可以是一个目录，也可以包含多个目录，每个目录都代表Go的一个工作区，用于存放源码文件(source file)、安装后的归档文件(archive file，后缀名为.a)和可执行文件(executable file)。 源码的构建与安装 源码导入从src开始搜索其子目录到指定代码包。产生的归档文件会放进pkg目录，产生可执行文件会被放入bin目录。如果构建的是库源码文件，那结果文件只会存在临时目录里，构建的意义在于检查和验证。如果构建的命令源码文件，结果文件会被搬运到源码所在目录中。构建和安装都会执行编译打包，而安装还会进行链接操作，如果安装的是库文件代码会放pkg目录，如果是安装的是命令源码，会放bin目录。 构建默认是不会编译依赖包的，但如果依赖包的归档文件不存在或源码有变化，依赖包会被编译。go build project.go -a -v强制编译并查看代码包编译过程，go build -x -n可以看到执行了哪些操作但不执行。 go get是从代码仓库中拉取代码包并放入GOBIN目录中 ~/$ go get -u -t github.com/astaxie/beego # -u是下载并安装代码包，不管工作区中是否存在，-t是同时下载测试所需代码包 ~/$ go get -d github.com/gin-gonic/gin # 只下载代码包 ~/$ go get -fix github.com/kataras/iris # 下载后先运行根据当前版本修正代码的工具，再安装 ~/$ go get -insecure github.com/smartystreets/goconvey # 允许使用非安全协议，如http 什么是程序实体？ 在Go中，是变量、常量、函数、结构体和接口的统称，程序实体的名字叫标识符。 什么是库源码文件？ 仅存放程序实体，可被调用。同一目录下的源码文件应该被声明属于同一代码包。声明的包名可以与目录不一致，导入路径与目录一致，而调用限定符要与生命的包名一致。标识符首字母大写为公有，可被包外代码调用，小写为私有。 类型推断有什么好处？ Go是静态类型的，在编译期就确定了类型，可以方便代码重构和维护，提升程序灵活性。 什么是重构？ 不改变程序与外界的交互方式和规则，只改变其内部实现。 什么是代码块？ 就是JavaScript的作用域，花括号组成代码块，main函数的代码块为空代码块，Go语言和源码共同形成了全域代码块。 变量重声明只发生在短变量声明时，变量只有一个，变量重声明类型始终一致。。重名变量，变量有多个，一山不容二虎，同一个作用域中，不能出现重名变量，嵌套作用域中，同名变量有屏蔽现象。 import . package会将包中公开的程序实体视作当前包的程序实体 什么是语法糖？ 语法糖就是某种便捷措施。 关于类型断言 类型断言表达式必须是接口类型，interface{}的花括号表示不包含任何内容的数据类型。 // 将container转换为空接口值，并判定是否为[]string类型 // 如果假，value=nil，ok=false value, ok := interface{}(container).([]string) 什么是类型字面量？ 类型字面量是表示数据结构本身的若干个字符，如string表示字符串类型 类型转换 对于整数类型和整数常量之类的类型转换，只要源值在目标类型可表示范围内即为合法。如果目标类型范围过小，则转为补码，截掉高位 整数值转为字符串类型，整数值应该是个有效的UnicodeCodePoint，否则将得到� 字符串类型与各种切片类型之间互转，UTF-8字符集中三个字符代表一个汉字，string转[]rune时会被拆分成Unicode字符 别名类型 // 别名类型 type type1 = string // 但[]type1和[]string是不同类型，因为它们潜在类型不同 // 新类型 type type2 string © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang专题/关于容器.html":{"url":"Golang/Golang专题/关于容器.html","title":"关于容器","keywords":"","body":"关于容器 数组与切片 数组和切片都是集合类，但数组是值类型，切片是引用类型，切片是对底层数组的片段引用 数组长度固定，须在声明时给定，长度是其类型属性的一部分。而切片可变长，不过不会变短 引用类型的传递成本低于值类型 切片的容量(cap)为底层数组从切片起始索引到末尾的长度，因为切片可以向右扩展 切片扩容并不会改变原切片，而是生成容量更大的切片，然后将原元素和新元素一并拷贝到新切片中。新切片的容量默认为原来的 2 倍，如果原切片长度大于 1024 时，则新切片容量为原切片容量的 1.25 倍，如果一次追加元素过多，新切片的容量即等于新切片长度 底层数组永远不会被替换，在扩容时生成新的底层数组，也同时生成新切片 链表 package main import ( \"container/list\" \"container/ring\" \"fmt\" ) var ( // 双向链表，零值长度为0，根元素不是有任何元素值 // 两个包级私有字段：一个是Element类型的root根元素，一个int类型的len // 公开字段Value，持有元素实际值 l list.List // 循环链表，零值长度为1，初始化后长度不可变 r ring.Ring ) func main(){ // 算法复杂度为O(N) fmt.Println(l.Len()) // 算法复杂度为O(1) fmt.Println(r.Len()) } 延迟初始化机制能分散初始化操作带来的计算量和存储空间的消耗。 字典 字典是一种哈希表(hash table)的特定实现，其中key类型受限，而value的类型任意。 字典键值类型不能是函数、字典、切片类型，因为Go规定键值之间要能支持判等操作，而这些类型不支持。因而求哈希和判等操作速度越快的类型越适合做键值类型。 如果键类型为接口或数组类型，它的实际类型也不能是这三种，但不要将字典的键值设置成为这两种类型，因为类型存在变数，要时刻保证代码的可控性。 package main import ( \"fmt\" ) var ( // 值为nil的字典 dict map[string]int ) func main(){ // 值为nil的字典在添加元素操作时会抛出panic，但在进行其他操作时不会报错 dict[\"one\"] = 1 } 什么是哈希值？ 哈希值通常是个无符号整数，哈希表会持有一定数量的哈希桶(bucket)均匀存储键值对。 哈希碰撞即不同值的哈希值可能相等。 字典是如何索引的？ 先将查找键值使用哈希函数(hash function)转换成哈希值 哈希表先用哈希值的低几位去定位哈希桶，然后再去桶中查找对应键，然后将结果返回 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang专题/通道与go语句.html":{"url":"Golang/Golang专题/通道与go语句.html","title":"通道与 go 语句","keywords":"","body":"通道与 go 语句 什么是通道？ 通道(channel)是Go语言中唯一一个可以满足并发安全性的特色数据类型。 package main import ( \"fmt\" ) var ( // 定义双向通道，通道为引用类型，零值为nil ch chan int // 单向通道，箭头代表通道方向 ch2 通道的发送与接收 对于同一通道，操作之间互斥。并发执行是因为代码块被分布在不同goroutine中 进入通道的是变量副本，离开通道的是通道中的元素副本，并删除通道内元素 操作不会被打断，保证元素完整性和通道唯一性。因而会出现阻塞 关闭通道中如有元素还未取出，则接收还会返回元素值，但第二个结果值为true表示通道已关闭，因此应由发送方决定通道的关闭，而非接收方 单向通道有什么用？ 用于约束代码，如编写模板、函数返回值列表之类。 select 语句 package main import ( \"math/rand\" \"fmt\" ) func main(){ intCh := [3]chan int{ make(chan int, 1), make(chan int, 1), } index := rand.Intn(2) intCh[index] 当所有case表达式先求值结束，然后再开始选择候选分支，如果有多个候选分支满足条件，则伪随机选择 默认分支有且只有一个，与编写位置无关 什么是 goroutine？ Don't communicate by sharing memory, share memory by communicating. 不要通过共享内存来通信，而是要通过通信来共享内存。 goroutine是并发编程模型中的用户级线程，架设在系统级线程之上。 Go语言中有用于调度goroutine和对接系统级线程的调度器。G(goroutine)和M(Machine)因为P(processor)的存在可以实现多对多。 主goroutine的go函数即main函数，go函数会明显滞后于它所属的go语句，只要go语句本身执行完毕，程序不会等待go函数的执行，而是立即去执行接下去的语句，从而实现异步并发执行。 如何让主协程等待其他协程？ 简单粗暴地让主协程time.Sleep(time.Millisecond * 500) 建一个长度与手动创建的协程数相等的通道chan struct，因为struct占用0 bytes，而且整个程序中永远是会存在一份 使用sync.WaitGroup类型 如何是多协程按既定顺序执行？ package main import ( \"fmt\" \"sync/atomic\" \"time\" ) // 原子操作对被操作的数值类型有约束，所以才需要统一转换成uint32 var count = uint32(0) func main() { for i := uint32(0); i © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang专题/关于函数.html":{"url":"Golang/Golang专题/关于函数.html","title":"关于函数","keywords":"","body":"关于函数 函数是引用类型。传入函数做的是浅表复制，传的都是值的副本。如果参数是引用类型，则拷贝了指向底层数组元素的指针，因此如果传入值为切片，函数内修改会影响切片本身。 什么是一等公民？ 函数作为一等(first class)公民，是函数式编程(functional programming)的重要特征。函数可以用于封装代码、分割功能、解耦逻辑、作为普通人在其他函数间传递、赋予变量、做类型判断或转换等。 高阶函数和闭包 高阶函数指函数将其他函数作为参数传入，或将其他函数作为结果返回。 package main import \"errors\" type operate func(x, y int) int type inner func(x, y int) (int, error) func demo(x, y int, fn operate) (int, error) { // 卫述语句用于检查关键的先决条件合法性，并在非法状态下立即终止代码块执行 if fn == nil { return 0, errors.New(\"Invalid Opetation\") } return fn(x, y), nil } // 闭包函数(closure) // 引用了自由变量呈现开放状态 func example(fn operate) inner { return func(x, y int) (int, error) { // 编译器会寻找绑定fn，捕获自由变量，开放状态变为确定 if fn == nil { return 0, errors.New(\"Invalid Operation\") } return fn(x, y), nil } } func main() { fn := func(x, y int) int { return x + y } demo(1, 2, fn) example(fn)(1, 2) } © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang专题/结构体与接口.html":{"url":"Golang/Golang专题/结构体与接口.html","title":"结构体与接口","keywords":"","body":"结构体与接口 Go 支持面向对象么？ 结构体将属性和方法封装在了一起，表现了面对对象编程(object-oriented programming)。 package main import \"fmt\" // 结构体类型是数据结构 type Animal struct { kind string } type Person struct { // 嵌入组合 Animal name string } // 函数可以匿名，方法必须拥有名字，而且必须做接收者(receiver)声明 // 接收者声明表示隶属类型，但不限定于结构体 func (a Animal) String() string { return a.kind } // 同名方法会重载，有屏蔽现象 func (p Person) String() string { return p.Animal.String() } func main() { p := Person{ name: \"Lili\", Animal: Animal{kind: \"human\"}, } fmt.Println(p.String()) } Go 是用嵌入字段实现继承么？ Go支持OOP，但没有继承的概念，而是嵌入组合。 OOP中的继承是牺牲一定代码简洁性来换取可扩展性，而且这种可扩展性是侵入式实现。 类型组合采用的是非声明的方式，是非侵入式的，不会破坏类型的封装或加重类型之间的耦合。 值方法与指针方法 方法的接收者类型必须是某个自定义的数据类型，而不能是接口类型或者是接口的指针类型。 值方法的接收者式该方法所属的类型值副本，方法内对副本的修改不会影响到原值，除非这个类型是引用类型。 一个自定义数据类型的方法集合仅会包含它的所有值方法，而该类型的指针类型方法集合包含所有值方法和指针方法。 package main import ( \"fmt\" ) // 结构体包裹字段声明 type Dog struct { name string } type Cat struct { name string } // 接口包裹方法定义 // 接口类型不会有重名，否则无法通过编译 type Pet interface { Call() SetName(name string) } // 值方法 func (d Dog) SetName(name string) { d.name = name } func (d Dog) Call() { fmt.Println(d.name) } // 指针方法 func (c *Cat) SetName(name string) { c.name = name } func (c Cat) Call() { fmt.Println(c.name) } func main() { kitty := Cat{\"kitty\"} doge := Dog{\"dog\"} // Pet为静态值，Dog和*Cat为动态类型 var p1 Pet = &kitty kitty.SetName(\"cat\") p1.SetName(\"Kitty\") p1.Call() kitty.Call() // 赋值传递的是副本，则不会变动原值 var p2 Pet = doge // 值方法传递的也是副本，原值不会变动 doge.SetName(\"doge\") doge.Call() p2.SetName(\"doge\") p2.Call() } 接口类型无法被值化或实例化，如果没有任何数据类型作为其实现，则该接口的值不可能存在。 动态类型如果为nil，Go会用专有数据结构iface的实例包装这个副本，这样它就变成了一个有类型的nil。 Duck Typing 如果一个数据类型的方法集合完全包含了接口的方法集合，那它就是这个接口的实现类型 如果两个方法的签名完全一致，且名称一模一样，则判定一个数据类型中的某一方法实现了某个接口类型中的某一方法 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang专题/关于指针.html":{"url":"Golang/Golang专题/关于指针.html","title":"关于指针","keywords":"","body":"关于指针 什么是指针？ 指针式指向某个确切内存地址的值 Go内建数据类型uintptr是个数值类型，根据计算机架构的不同，可以存储 32 位或 64 位无符号整数来表示指针 Go标准库unsafe/Pointer可以表示任何只想可寻址(addressable)的值的指针 什么是不可寻址？ 不可寻址无法用取值操作符&获取指针。 常量的值、基本类型值的字面量、函数和方法字面量、对字符串变量的索引表达式和切片表达式的结果值，会被存储到确切的内存区域中，其值不可变，所以不可寻址 算术操作的结果值、类型转换和类型断言表达式的结果值、对各种字面量的索引表达式和切片表达式的结果值、函数和方法的调用表达式的结果值、对结构体字面量的选择表达式的结果值、接收表达式的结果值是一种临时结果，在将结果值赋值给任何变量之前，取得其内存地址毫无意义，所以不可寻址 对字典变量的索引表达式的结果值不是临时结果，但也无法寻址，因为其键值对存储位置可能发生变动，外界无法感知，获取其指针不安全，所以不可寻址 自增自减语句和赋值操作符左边的表达式的结果值必须可寻址，但对字典字面量和字典变量索引表达式的结果值例外 对切片字面量的索引结果值却是可寻址的，因为底层数组的元素有确切内存地址 如果将临时结果赋给一个变量，则可寻址，指针指向变量所持有的值 带有range的for语句中，表达式左边的结果值要可寻址 unsafe.Pointer unsafe.Pointer可以绕过Go语言的编译器和其他工具检查，嵌入内存修改数据，很危险，慎用。 package main import ( \"fmt\" \"unsafe\" ) type Person struct { name string } func main() { a := Person{ name: \"Lili\", } aPointer := &a /* 1. 指针和unsafe.Pointer可以互转 2. uintptr和unsafe.Pointer可以互转 3. 指针无法和uintptr互转 */ aPtr := uintptr(unsafe.Pointer(aPointer)) // unsafe.Offsetof是获取两个值在内存中起始存储地址之间的偏移量，以字节为单位 namePtr := aPtr + unsafe.Offsetof(aPointer.name) // 获取指针位置 nameP := (*string)(unsafe.Pointer(namePtr)) fmt.Println(nameP) } © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang专题/关于流程控制.html":{"url":"Golang/Golang专题/关于流程控制.html","title":"关于流程控制","keywords":"","body":"关于流程控制 range 表达式 range表达式只会在for语句开始执行被求值一次，无论后边有多少次迭代 range表达式的求值结果会被复制，即被迭代对象是range表达式的副本 switch 语句 如果switch表达式的结果值是无状态常量，则会被默认自动转化为此种常量默认类型的值 switch与各个case表达式之间进行判等操作需要同类型 case表达式之间不允许值相等的情况，而且类型判断的case表达式必须直接由类型字面量表示 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang专题/关于异常捕获.html":{"url":"Golang/Golang专题/关于异常捕获.html","title":"关于异常捕获","keywords":"","body":"关于异常捕获 package main import ( \"fmt\" \"os\" \"os/exec\" ) // error是内建接口类型 func printError(i int, err error) { // 对已有相关变量且类型相同的错误值，使用判等 if err == nil { fmt.Println(\"nil error\") return } err = underlyingError(err) // 对没有相关变量且类型位置的错误值，只能使用其错误信息字符串表示 switch err { case os.ErrClosed: fmt.Printf(\"error(Closed)[%d]: %s\\n\", i, err) case os.ErrInvalid: fmt.Printf(\"error(Invalid)[%d]: %s\\n\", i, err) case os.ErrPermission: fmt.Printf(\"error(Permission)[%d]: %s\\n\", i, err) } } func underlyingError(err error) error { // 对已知范围内的潜在错误值，使用类型switch语句 switch err := err.(type) { case *os.PathError: return err.Err case *os.LinkError: return err.Err case *os.SyscallError: return err.Err case *exec.Error: return err.Err } return err } panic 代码触发panic，初始panic详情被建立，控制权转移至调用栈的上一级，这意味着代码所属函数执行终止，然后控制权依次沿调用栈反向传播至顶层(最外层函数)，然后被Go语言系统收回，随即程序崩溃并终止运行，承载程序此次运行的进程消亡。在控制权传播过程中，panic详情被积累完善，并在程序终止之前被打印出来。 package main import ( \"errors\" \"fmt\" ) func main() { // 延迟调用，将会在函数结束前执行 // 如果有多条defer语句，调用顺序由下至上，因为defer队列是FILO的 defer func() { // 用于平息恐慌，并返回一个interface{}，其中包含引发的panic的值 if p := recover(); p != nil { fmt.Printf(\"panic: %s\", p) } }() // Go语言提供内建函数panic用来处理不致命异常 // 唯一参数是interface{} panic(errors.New(\"Err\")) } © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang专题/关于测试.html":{"url":"Golang/Golang专题/关于测试.html","title":"关于测试","keywords":"","body":"关于测试 一般情况下，测试源码文件只会针对某个命令源码文件或库源码文件做测试，所以应该将其放在同一个代码包内。 测试源码文件*_test.go应该以被测源码文件名为前导。 对于功能测试(test)，测试函数名应以Test为前缀，函数参数类型为*testing.T。对于基准测试(benchmark)，测试函数名应以Benchmark为前缀，函数参数类型为*testing.B。对于示例测试(example)，测试函数名应以Example为前缀，函数参数类型无限制。 示例测试严格来讲其实也是功能测试，只是更关注程序打印出来的内容。 默认情况命令会串行执行测试函数， go test 命令 ~/$ go clean -testcache # 清除测试缓存，go test对测试成功的结果会进行缓存 ~/$ go clean -cache # 清理全部缓存 ~/$ go test -parallel 10 demo -v # -parallel是指定最大并发数，对性能测试无效，-v是输出所有常规测试日志 package main func TestDemo(t *testing.T){ // 执行t.FailNow当前函数会立即终止 t.Fail() // t.Log与t.Logf用于打印常规测试日志 // t.Error与t.Errorf相当于连续调用Fail和Log方法 // t.Fatal和t.Fatalf相当于Log之后FailNow t.Fatal(\"Failed\") } 执行性能测试 ~/$ go test -bench=. -run=^$ -cpu=[8, 6] -count 5 demo # -bench=.表示执行所有基准测试函数，-run=^$表示不执行功能测试函数，-cpu代表可以同时运行goroutine的逻辑CPU的最大个数，-count代表重复执行测试函数数 \\begin{aligned} 性能测试函数的执行次数=&逻辑CPU列表中的正整数个数\\\\ &\\times重复执行测试函数数\\\\ &\\times探索性执行测试函数的实际次数 \\end{aligned} \\begin{aligned} 功能测试函数的执行次数=&逻辑CPU列表中的正整数个数\\\\ &\\times重复执行测试函数数 \\end{aligned} 单元测试就是对单一的功能模块进行边界清晰的测试，并且不参杂任何对外部环境的检测，因而如不可避免依赖一些外部环境的话，应该在测试中mock外部环境 package main import testing func BenchmarkDemo(b *testing.B) { // 性能测试计时器 b.StopTimer() b.StartTimer() } © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang专题/互斥锁、读写锁、条件变量与原子操作.html":{"url":"Golang/Golang专题/互斥锁、读写锁、条件变量与原子操作.html","title":"互斥锁、读写锁、条件变量与原子操作","keywords":"","body":"互斥锁、读写锁、条件变量与原子操作 并发和并行 多线程程序在单核上运行为并发，同一时间点单任务运行 多线程程序在多核上运行为并行，多任务在同一时间点运行 协程 独立栈空间 共享堆空间 调度由用户控制 轻量级线程 互斥锁 竞态条件race condition是指数据被多个线程共享，产生争用和冲突，往往会破坏共享数据的一致性。 多个并发运行的线程对共享资源的访问是完全串行的，由于要访问资源而必须进入的区域叫临界区(critical section)。 互斥量mutual exclusion可以用来保护一个临界区或一组相关临界区，用于保证同一时刻只有一个协程进入临界区。 package main import ( \"sync\" \"runtime\" ) var mtx sync.Mutex func main() { // 不要重复上锁，否则会阻塞协程 // 不要跨函数直接传递互斥锁，多副本之间的互斥锁完全独立，没有意义 mtx.Lock() // 不要忘记解锁，必要时使用defer // 不要对未上锁或已解锁的互斥锁解锁 mtx.Unlock() } 死锁deadlock即所有用户级协程全部处于等待状态，程序必然崩溃。 读写锁 sync.RWMutex中，多个写无法同时进行，读与写无法同时进行，但多个读可以同时进行。 条件变量 条件变量(conditional variable)是用于协调想要访问共享资源的那些线程的。 package main import ( \"sync\" \"runtime\" ) var ( mailbox uint8 lock sync.RWMutex ) func main() { // 获取当前系统CPU数 cpuNum := runtime.NumCPU() runtime.GOMAXPROCS(cpuNum) // 条件变量基于互斥锁，需要一个sync.Locker类型的参数 sendCond := sync.NewCond(&lock) recvCond := sync.NewCond(lock.RLocker()) sign := make(chan struct{}, 3) go func() { defer func() { sign 原子操作 能真正保证原子性执行的只有原子操作，可以完全消除竞态条件，并能够绝对保证并发安全性。 原子操作不能被中断，所以要求足够简单而且快速。但如果原子操作迟迟不能完成，将会给计算机执行指令效率带来极大影响，所以操作系统层面只针对二进制位或整数的原子操作提供支持。 sync.atomic 包中的原子操作有add加法、compare and swap比较并交换、load加载、store存储和swap交换。 可操作的数据类型有int32、int64、uint32、uint64、uintptr和unsafe.Pointer。 自旋锁 CAS算法是一种无锁算法，即不使用锁的情况下实现多线程之间变量同步，也叫非阻塞同步(Non-blocking Synchronization)。 package main import ( \"runtime\" \"sync\" \"sync/atomic\" ) type spinLock uint32 func (sl *spinLock) Lock() { // 当且仅当需要读写的内存值等于进行比较的值时，以原子操作的方式用新值来替换原值，一般情况下是个自旋操作，即不断重试直至满足条件 for !atomic.CompareAndSwapUint32((*uint32)(sl), 0, 1) { runtime.Gosched() } } func (sl *spinLock) Unlock() { atomic.StoreUint32((*uint32)(sl), 0) } func NewSpinLock() sync.Locker { var lock spinLock return &lock } © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang专题/并发中的其它协程同步工具.html":{"url":"Golang/Golang专题/并发中的其它协程同步工具.html","title":"并发中的其它协程同步工具","keywords":"","body":"并发中的其它协程同步工具 sync.Value 不能存储nil 存储初值决定其存储类型 不要存储引用类型 sync.WaitGroup 和 sync.Once package main import ( \"fmt\" \"sync\" ) var ( // 仅用原子操作实现并发等待组 wg sync.WaitGroup // 用原子操作和互斥锁实现执行一次 oc sync.Once ) func main() { count := 3 // 计数器限制执行协程数，需要事先知道所需执行的协作流程数 wg.Add(count) for i := 0; i context.Context package main import ( // 值可以被任意扩散，还可以被用来传递额外信息和信号，且并发安全。 \"context\" \"fmt\" \"sync/atomic\" \"time\" ) func main() { var num int32 // 调用协程数取决于循环数 total := 4 // Context值全局唯一，即根节点 // 根节点不提供任何额外功能，不能被撤销，也不携带数据 root := context.Background() // cxt是一个可撤销的值，cancalFunc是一个撤销函数 cxt, cancelFunc := context.WithCancel(root) for i := 1; i 撤销信号传递深度优先。 撤销函数被调用之后，对应的Context值会先使用Done方法关闭它内部的接收通道。接着往它的所有子节点传递撤销信号，最后Context值会断开与其父值的关联。 context.WithValue函数得到的Context值无法撤销，撤销信号传播时，遇到它们则直接跨过，并尝试传递信号给它们的子值。 package main import ( \"context\" \"fmt\" ) type key int func main() { keys := []key{ 10, 20, 30, } vals := []string{ \"10\", \"20\", \"30\", } root := context.Background() node1, cancelFunc1 := context.WithCancel(root) defer cancelFunc1() // Context接口没有提供改变数据的方法，只能通过添加含数据的Context值或撤销该值的父值来增删数据 node2 := context.WithValue(node1, keys[0], vals[0]) node3 := context.WithValue(node2, keys[1], vals[1]) fmt.Println(node3.Value(keys[0]), node3.Value(keys[1]), node3.Value(keys[2])) } 临时对象池 sync.Pool 临时对象即不需要持续使用的某一类值，可以在任何时候创建和销毁，完全不会影响到程序的功能。 临时对象池可以被当作针对某种数据的缓存。 Go语言运行时，系统中的垃圾回收器，在每次开始执行之前会对所有创建的临时对象池中的值进行全面清除。 首先sync包初始化时，会向运行时系统注册一个池清理函数。sync有个包级私有全局变量，池汇总列表。 池清理函数会先遍历池汇总列表，先将池中的私有临时对象和共享临时对象列表置为nil，然后再将池中所有本地池列表销毁，最后将池汇总列表重置为空切片。然后在稍后的垃圾回收中，临时对象池会被当作垃圾销毁，所占用的内存空间也将会被回收。 临时对象池顶层时本地池列表，长度与调度器中的processor数相同，用于分散存储压力和性能压力。临时对象池的Put和Get方法会获取到哪一个本地池，取决于调用它的代码所在的goroutine关联的调度器。 本地池列表中的每个本地池包含存放私有临时对象的字段private、代表共享临时对象列表字段shared和一个sync.Mutex类型的嵌入字段。 Put方法总会先尝试把新的临时对象存储到对应本地池的private字段中，只有在private已存在某个值时，才会去访问shared字段，Get方法同理，只有private字段中的值为nil时，才会去访问shared字段。 shared字段是共享的，受互斥锁保护。 如果获取不到，将会调用可创建临时对象的New函数，需要初始化时给定，否则返回nil。 sync.Map Go自带的字典类型map并不是并发安全的，同一时间段内，让不同协程对同一字典进行读写操作可能会出问题。 并发安全字典的键不能是函数、字典或切片类型。因为这些的实际类型得到运行期间才能确定，编译器无法在编译时进行检查。 其次还得保证键的类型可判等，拿不准可以用reflect.Typeof得到键值对应的反射类型值，再调用Comparable方法。 如何保证并发安全字典中的键值类型正确性？ 重载增删改查方法。 只存某种特定类型值 封装时候限定键值类型为reflect.Type，然后在方法中判等 并发安全字典如何尽量避免使用锁？ sync.Map类型中只读字典read字段相当于一个快照，将值转化为unsafe.Pointer类型存储。只读字典是逻辑删除。 当并发安全字典访问只读字典时不需要锁，只有在只读字典中没有，脏字典里可能有时，才会在锁的保护下去读取dirty字段。 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "},"Golang/Golang专题/关于IO.html":{"url":"Golang/Golang专题/关于IO.html","title":"关于 IO","keywords":"","body":"关于 IO 编码规范 ASCII 码 American Standard Code for Information Interchange，最初是美国国家标准学会(ANSI)制定的单字节字符编码方案，后被国际标准化组织(ISO)定位ISO 646标准，适用所有拉丁文字母。 使用单字节的二进制数来编码字符，标准ASCII码用一字节的最高比特位作为奇偶校验位，扩展ASCII码将此位也用作表示字符。 Unicode 编码 采用十六进制表示法来表示Unicode代码点的整数值，并使用U+作为前缀。 目前提供三种不同的编码规范UTF-8、UTF-16和UTF-32。 UTF是Universal Character Set Transformation Format，Unicode转换格式，代表字符与字节序列之间的转换方式。 UTF-8会以 8bit作为一个编码单元，它与标准ASCII码兼容。 在Go语言底层，字符串类型的值就是用UTF-8编码值来表达的。 package main import ( \"fmt\" ) func main(){ str := \"Golang\" fmt.Println([]rune(str)) // 中文字符需要3个字节 fmt.Println([]byte(str)) } strings.Builder 已存在的内容不可变，但可拼接 减少内存分配和内容拷贝次数 可将内容重置，可重复用值 package main import ( \"fmt\" \"io\" \"strings\" ) var builder strings.Builder func main() { str := \"Halo World\" // 构建字符串,底层有个[]byte,按需扩容 builder.Write([]byte(str)) // 读取字符串 reader := strings.NewReader(str) offset := int64(2) // 阅读指针,维护了一个已读计数器 index, _ := reader.Seek(offset, io.SeekCurrent) fmt.Println(index) buff := make([]byte, reader.Size()) // 将剩余量存入数组 reader.Read(buff) fmt.Println(buff) } bytes.Buffer bytes包用于处理字节序列和字节切片。Buffer的Len方法获取的是未读内容长度，有可能变小也可能变大。 Cap_{新容器}=2 \\times Cap_{旧容器}+所需字节数 io 包 io.Reader 的扩展接口 io.ReadWriter：包含基本的字节序列读取和写入方法 io.ReadCloser：除基本字节序列读取方法外，还拥有一个基本关闭方法Close io.ReadWriteCloser：io.Reader、io.Writer和io.Closer的扩展接口组合 io.ReadSeeker：拥有一个用于寻找读写位置的基本方法Seek io.ReadWriteSeeker：io.Reader、io.Writer和io.Seeker的扩展接口组合 io.Reader 的实现类型 *io.LimitedReader：包装io.Reader类型的值，但读取的总数据量受限 *io.SectionReader：包装io.Reader类型的值，限定Read方法只能够读取原始数据中的某一段 *io.teeReader：结果值的Read方法会把io.Reader上的数据经过字节切片写入到io.Writer中去 *io.multiReader：多对象读取器，接收多个io.Reader的值，返回一个io.multiReader的值。调用Read会从前面的对象中顺序读取数据 *io.pipe：实现了io.Reader和io.Writer，是io包的同步内存通道的核心实现 *io.PipeReader：io.pipe的代理类型，并实现了io.ReadCloser，同时定义了同步内存通道的读取端 bufio 包 缓冲区是一个数据存储中介，介于底层读取器和读取方法及其调用方之间。底层读取器即初始化此类值时传入的io.Reader类型值。 Reader值会先从其所属的缓冲区中读取数据，同时还会预先从底层读取器中读出一部分数据暂存缓冲区。这样可以在大多数时候降低读取方法的执行时间。 © Senkita All Right Reserved，Powered by Senkita本页面最新修订时间： 2020-12-24 04:07:57 "}}