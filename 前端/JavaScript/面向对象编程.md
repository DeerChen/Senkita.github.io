# 面向对象编程

```js
let obj = {
    name: '',
    sayName: function () {
        // 指向对象引用
        return this.name;
    },
};

// 构造函数
function Bird(name) {
    this.name = name;
}

let bird = new Bird(); // 实例化
console.log(bird instanceof Bird); // 验证实例从属
bird.hasOwnProperty('name'); // 自身属性查询
Bird.prototype.isPrototypeOf(bird); // 原型对象判断

// 原型链
Bird.prototype = {
    constructor: Bird,
    numLeg: 2,
};
bird.constructor === Bird; // 对象溯源

function Animal() {}
Animal.prototype.eat = function () {
    console.log('eat');
};

Bird.prototype = Object.create(Animal.prototype); // 继承
Bird.prototype.constructor = Bird; // 消除副作用
// 重载
Bird.prototype.eat = function () {
    console.log(this.name + 'eat');
};
```

1. 构造函数首字母大写
2. 原型链上的属性所有实例共享
3. 原型链添加属性有副作用，会将构造函数覆盖

## Mixins

为不相关的对象提供相同的方法。

```js
let motionModule = (function () {
    return {
        flyMixin: function (obj) {
            obj.fly = function () {
                console.log('Flying, wooosh!');
            };
        },
    };
})();

let bird = {
    name: 'bird',
};

let plane = {
    name: 'plane',
};

motionModule.flyMixin(bird);
motionModule.flyMixin(plane);
```

## 闭包

```js
function Bird() {
    let egg = 10; // 私有变量

    this.getEggCount = function () {
        return egg;
    };
}
```

1. 公共方法与私有变量在相同的`Context`中声明，公共方法始终能够访问创建它的上下文，形成闭包
