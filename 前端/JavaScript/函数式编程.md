# 函数式编程

1. 函数式编程不依赖程序状态或全局变量，只依靠传递进来的参数进行计算，在函数以外副作用最小
2. 理想状态下，应为相同输入必然得到相同输出的纯函数，而无会改变事物结果的副作用
3. 回调：将函数传入另一个函数，由其决定函数调用
4. 高阶函数：将函数作为参数或作为返回值的函数
5. `lambda`：传入或从高阶函数中返回出来的函数
6. 如果会产生副作用，必须始终显式声明依赖项

```js
const arr = [
    { name: 'zhangsan', age: 17 },
    { name: 'lisi', age: 18 },
    { name: 'wangwu', age: 19 },
    { name: 'zhaoliu', age: 20 },
];

arr.push(['a', 'b', 'c']); // 添加元素

const sum = arr.reduce((sumVal, a) => {
    sumVal + a.age;
}, 0);

const ages = arr.map((a) => a.age); // map迭代数组项
const person = arr.filter((a) => a.name.length < 5); // filter过滤
const s = arr.slice(1, 3); // 切片
const newArr = arr.splice(3, 1); // 删除元素
const longArr = arr.concat([1, 2, 3]); // 拼接数组

const sortedArr = arr.sort(function (a, b) {
    return a - b;
}); // 排序

ages.every(function (val) {
    return val < 20;
});
ages.some(function (val) {
    return val < 20;
});

const strArr = arr[0].name.split(''); // 拆分字符串
strArr.join(' '); // 拼接字符串
```

1. `reduce`方法需要加入初值
2. `push`方法不是函数式编程，它使得原数组变异
3. `map`、`filter`、`splice`和`concat`方法都不改变原始数组，返回的是一个新数组
4. `slice`方法也不改变原始数组，返回元素副本
5. `sort`方法有副作用，可以使用空数组来规避副作用
6. `every`方法全满足返回`true`
7. `some`方法有满足即返回`true`
